import Mathlib


/-- The finite field on two elements. -/
abbrev Z2 : Type := Fin 2

variable {X Y : Type} [DecidableEq X] [DecidableEq Y]

/-- Is given set of columns in the standard representation matrix independent? -/
def Matrix.IndepCols (A : Matrix X Y Z2) (S : Set (X ⊕ Y)) : Prop :=
  LinearIndependent Z2 ((Matrix.fromColumns 1 A).submatrix id ((↑) : S → X ⊕ Y)).transpose

/-- The empty set of columns in linearly independent. -/
theorem Matrix.IndepCols_empty (A : Matrix X Y Z2) : A.IndepCols ∅ := by
  sorry

/-- A subset of a linearly independent set of columns in linearly independent. -/
theorem Matrix.IndepCols_subset (A : Matrix X Y Z2) (I J : Set (X ⊕ Y)) (hAJ : A.IndepCols J) (hIJ : I ⊆ J) :
    A.IndepCols I := by
  sorry

/-- A nonmaximal linearly independent set of columns can be augmented with another linearly independent column. -/
theorem Matrix.IndepCols_aug (A : Matrix X Y Z2) (I B : Set (X ⊕ Y))
    (hAI : A.IndepCols I) (nonmax : ¬Maximal A.IndepCols I) (hAB : Maximal A.IndepCols B) :
    ∃ x ∈ B \ I, A.IndepCols (insert x I) := by
  sorry

/-- Any set of columns has the maximal subset property. -/
theorem Matrix.IndepCols_maximal (A : Matrix X Y Z2) (S : Set (X ⊕ Y)) :
    Matroid.ExistsMaximalSubsetProperty A.IndepCols S := by
  sorry

/-- Binary matroid generated by its standard representation matrix. -/
def Matrix.toIndepMatroid (A : Matrix X Y Z2) : IndepMatroid (X ⊕ Y) where
  E := Set.univ
  Indep := A.IndepCols
  indep_empty := A.IndepCols_empty
  indep_subset := A.IndepCols_subset
  indep_aug := A.IndepCols_aug
  indep_maximal S _ := A.IndepCols_maximal S
  subset_ground := fun _ _ _ _ => trivial

/-- Binary matroid on the ground set `(X ⊕ Y)`. -/
structure BinaryMatroid (X Y : Type) [DecidableEq X] [DecidableEq Y]
  extends IndepMatroid (X ⊕ Y) where
    B : Matrix X Y Z2
    hB : B.toIndepMatroid = toIndepMatroid

def Matrix.TU (A : Matrix X Y ℚ) : Prop :=
  ∀ k : ℕ, ∀ f : Fin k → X, ∀ g : Fin k → Y,
    Function.Injective f → Function.Injective g →
      (A.submatrix f g).det = 0 ∨
      (A.submatrix f g).det = 1 ∨
      (A.submatrix f g).det = -1

/-- Regular matroid on the ground set `(X ⊕ Y)`. -/
structure RegularMatroid (X Y : Type) [DecidableEq X] [DecidableEq Y]
  extends BinaryMatroid X Y where
    A : Matrix X Y ℚ
    hA : (Matrix.fromColumns (1 : Matrix X X ℚ) A).TU
    hBA : ∀ i : X, ∀ j : Y, if B i j = 0 then A i j = 0 else A i j = 1 ∨ A i j = -1

/-- Matroid casting, i.e., renaming the type without changing the elements; implemented for independent sets. -/
def IndepMatroid.cast (M : IndepMatroid X) (hXY : X = Y) : IndepMatroid Y where
  E := hXY ▸ M.E
  Indep := hXY ▸ M.Indep
  indep_empty := by subst hXY; exact M.indep_empty
  indep_subset := by subst hXY; exact M.indep_subset
  indep_aug := by subst hXY; exact M.indep_aug
  indep_maximal := by subst hXY; exact M.indep_maximal
  subset_ground := by subst hXY; exact M.subset_ground

/-- Matroid isomorphism, i.e., renaming the elements (the type changes as well); implemented for independent sets. -/
def IndepMatroid.mapEquiv (M : IndepMatroid X) (eYX : Y ≃ X) : IndepMatroid Y where
  E := eYX.symm '' M.E
  Indep I := ∃ I₀, M.Indep I₀ ∧ I = eYX.symm '' I₀
  indep_empty := ⟨∅, M.indep_empty, by simp⟩
  indep_subset I J hI hJ := by
    refine ⟨eYX '' I, ?_, by simp [Equiv.eq_image_iff_symm_image_eq eYX]⟩
    obtain ⟨I', hIJ⟩ := hI
    have := M.indep_subset (I := eYX '' I) (J := eYX '' J)
    simp_all
  indep_aug := by sorry
  indep_maximal I := by sorry
  subset_ground I hI := by have := M.subset_ground (eYX '' I); aesop

def BinaryMatroid.mapEquiv {X' Y' : Type} [DecidableEq X'] [DecidableEq Y']
    (M : BinaryMatroid X Y) (eX : X' ≃ X) (eY : Y' ≃ Y) : BinaryMatroid X' Y' where
  toIndepMatroid := M.toIndepMatroid.mapEquiv (Equiv.sumCongr eX eY)
  B := fun i j => M.B (eX i) (eY j)
  hB := by sorry

variable {X₁ X₂ Y₁ Y₂ : Type} [DecidableEq X₁] [DecidableEq Y₁] [DecidableEq X₂] [DecidableEq Y₂]

/-- Matrix-level 1-sum for matroids defined by their standard representation matrices. -/
abbrev Matrix.oneSumComposition (A₁ : Matrix X₁ Y₁ Z2) (A₂ : Matrix X₂ Y₂ Z2) :
    Matrix (X₁ ⊕ X₂) (Y₁ ⊕ Y₂) Z2 :=
  Matrix.fromBlocks A₁ 0 0 A₂

/-- Matrix-level 2-sum for matroids defined by their standard representation matrices; does not check legitimacy. -/
abbrev Matrix.twoSumComposition (A₁ : Matrix X₁ Y₁ Z2) (x : Y₁ → Z2) (A₂ : Matrix X₂ Y₂ Z2) (y : X₂ → Z2) :
    Matrix (X₁ ⊕ X₂) (Y₁ ⊕ Y₂) Z2 :=
  Matrix.fromBlocks A₁ 0 (fun i j => y i * x j) A₂

/-- Matrix-level 3-sum for matroids defined by their standard representation matrices; does not check legitimacy. -/
noncomputable abbrev Matrix.threeSumComposition (A₁ : Matrix X₁ (Y₁ ⊕ Fin 2) Z2) (A₂ : Matrix (Fin 2 ⊕ X₂) Y₂ Z2)
    (z₁ : Y₁ → Z2) (z₂ : X₂ → Z2)
    (D : Matrix (Fin 2) (Fin 2) Z2) (D₁ : Matrix (Fin 2) Y₁ Z2) (D₂ : Matrix X₂ (Fin 2) Z2) :
    Matrix ((X₁ ⊕ Unit) ⊕ (Fin 2 ⊕ X₂)) ((Y₁ ⊕ Fin 2) ⊕ (Unit ⊕ Y₂)) Z2 :=
  let D₁₂ : Matrix X₂ Y₁ Z2 := D₂ * D⁻¹ * D₁
  Matrix.fromBlocks
    (Matrix.fromRows A₁ (Matrix.row Unit (Sum.elim z₁ ![1, 1]))) 0
    (Matrix.fromBlocks D₁ D D₁₂ D₂) (Matrix.fromColumns (Matrix.col Unit (Sum.elim ![1, 1] z₂)) A₂)

/-- Matroid-level (independent sets) 1-sum for matroids defined by their standard representation matrices. -/
def BinaryMatroid.oneSum (M₁ : BinaryMatroid X₁ Y₁) (M₂ : BinaryMatroid X₂ Y₂) :
    BinaryMatroid (X₁ ⊕ X₂) (Y₁ ⊕ Y₂) :=
  ⟨_, Matrix.oneSumComposition M₁.B M₂.B, rfl⟩

/-- Matroid-level 2-sum for matroids defined by their standard representation matrices; now checks legitimacy. -/
def BinaryMatroid.twoSum (M₁ : BinaryMatroid (X₁ ⊕ Unit) Y₁) (M₂ : BinaryMatroid X₂ (Unit ⊕ Y₂)) :
    BinaryMatroid (X₁ ⊕ X₂) (Y₁ ⊕ Y₂) × Prop :=
  let B₁ := M₁.B -- the standard representation matrix of `M₁`
  let B₂ := M₂.B -- the standard representation matrix of `M₂`
  let A₁ : Matrix X₁ Y₁ Z2 := B₁ ∘ .inl -- the top submatrix of `B₁`
  let A₂ : Matrix X₂ Y₂ Z2 := (B₂ · ∘ .inr) -- the right submatrix of `B₂`
  let x : Y₁ → Z2 := (B₁ ∘ .inr) () -- the bottom row of the matrix `B₁`
  let y : X₂ → Z2 := ((B₂ · ∘ .inl) · ()) -- the leftmost column of the matrix `B₂`
  ⟨
    ⟨_, Matrix.twoSumComposition A₁ x A₂ y, rfl⟩,
    x ≠ 0 ∧ y ≠ 0
  ⟩

/-- Matroid-level 3-sum for matroids defined by their standard representation matrices; now checks legitimacy. -/
noncomputable def BinaryMatroid.threeSum
    (M₁ : BinaryMatroid ((X₁ ⊕ Unit) ⊕ Fin 2) ((Y₁ ⊕ Fin 2) ⊕ Unit))
    (M₂ : BinaryMatroid (Unit ⊕ (Fin 2 ⊕ X₂)) (Fin 2 ⊕ (Unit ⊕ Y₂))) :
    BinaryMatroid ((X₁ ⊕ Unit) ⊕ (Fin 2 ⊕ X₂)) ((Y₁ ⊕ Fin 2) ⊕ (Unit ⊕ Y₂)) × Prop :=
  let B₁ := M₁.B -- the standard representation matrix of `M₁`
  let B₂ := M₂.B -- the standard representation matrix of `M₂`
  let A₁ : Matrix X₁ (Y₁ ⊕ Fin 2) Z2 := ((B₁ ∘ .inl ∘ .inl) · ∘ .inl) -- the top left submatrix
  let A₂ : Matrix (Fin 2 ⊕ X₂) Y₂ Z2 := ((B₂ ∘ .inr) · ∘ .inr ∘ .inr) -- the bottom right submatrix
  let z₁ : Y₁ → Z2 := fun j => B₁ (.inl (.inr ())) (.inl (.inl j)) -- the middle left "row vector"
  let z₂ : X₂ → Z2 := fun i => B₂ (.inr (.inr i)) (.inr (.inl ())) -- the bottom middle "column vector"
  let D_₁ : Matrix (Fin 2) (Fin 2) Z2 := fun i j => B₁ (.inr i) (.inl (.inr j)) -- the bottom middle 2x2 submatrix
  let D_₂ : Matrix (Fin 2) (Fin 2) Z2 := fun i j => B₂ (.inr (.inl i)) (.inl j) -- the middle left 2x2 submatrix
  let D₁ : Matrix (Fin 2) Y₁ Z2 := fun i j => B₁ (.inr i) (.inl (.inl j)) -- the bottom left submatrix
  let D₂ : Matrix X₂ (Fin 2) Z2 := fun i j => B₂ (.inr (.inr i)) (.inl j) -- the bottom left submatrix
  ⟨
    ⟨_, Matrix.threeSumComposition A₁ A₂ z₁ z₂ D_₁ D₁ D₂, rfl⟩,
    IsUnit D_₁ ∧ D_₁ = D_₂ -- the matrix `D_₁ = D_₂` (called D-bar in the book) is invertible
  ⟩

/-- Matroid `M` is a result of 1-summing `M₁` and `M₂` (should be equivalent to direct sums). -/
def BinaryMatroid.Is1sum (M : BinaryMatroid X Y) (M₁ : BinaryMatroid X₁ Y₁) (M₂ : BinaryMatroid X₂ Y₂) : Prop :=
  ∃ eX : X ≃ (X₁ ⊕ X₂), ∃ eY : Y ≃ (Y₁ ⊕ Y₂),
    M = (BinaryMatroid.oneSum M₁ M₂).mapEquiv eX eY

/-- Matroid `M` is a result of 2-summing `M₁` and `M₂` in some way. -/
def BinaryMatroid.Is2sum (M : BinaryMatroid X Y) (M₁ : BinaryMatroid X₁ Y₁) (M₂ : BinaryMatroid X₂ Y₂) : Prop :=
  let B₁ := M₁.B -- the standard representation matrix of `M₁`
  let B₂ := M₂.B -- the standard representation matrix of `M₂`
  ∃ X' Y' : Type, ∃ _ : DecidableEq X', ∃ _ : DecidableEq Y', -- indexing types for the shared parts
    ∃ hX : X₁ = (X' ⊕ Unit), ∃ hY : Y₂ = (Unit ⊕ Y'), ∃ eX : X ≃ (X' ⊕ X₂), ∃ eY : Y ≃ (Y₁ ⊕ Y'),
      let M₀ := BinaryMatroid.twoSum
        ⟨M₁.cast (congr_arg (· ⊕ Y₁) hX), hX ▸ B₁, by subst hX; convert M₁.hB⟩
        ⟨M₂.cast (congr_arg (X₂ ⊕ ·) hY), hY ▸ B₂, by subst hY; convert M₂.hB⟩
      M = M₀.fst.mapEquiv eX eY ∧ M₀.snd

/-- Matroid `M` is a result of 3-summing `M₁` and `M₂` in some way. -/
def BinaryMatroid.Is3sum (M : BinaryMatroid X Y) (M₁ : BinaryMatroid X₁ Y₁) (M₂ : BinaryMatroid X₂ Y₂) : Prop :=
  let B₁ := M₁.B -- the standard representation matrix of `M₁`
  let B₂ := M₂.B -- the standard representation matrix of `M₂`
  ∃ X₁' Y₁' : Type, ∃ _ : DecidableEq X₁', ∃ _ : DecidableEq Y₁', -- indexing types for the shared parts
  ∃ X₂' Y₂' : Type, ∃ _ : DecidableEq X₂', ∃ _ : DecidableEq Y₂', -- indexing types for the shared parts
    ∃ hX₁ : X₁ = ((X₁' ⊕ Unit) ⊕ Fin 2), ∃ hY₁ : Y₁ = ((Y₁' ⊕ Fin 2) ⊕ Unit),
    ∃ hX₂ : X₂ = (Unit ⊕ (Fin 2 ⊕ X₂')), ∃ hY₂ : Y₂ = (Fin 2 ⊕ (Unit ⊕ Y₂')),
      ∃ eX : X ≃ ((X₁' ⊕ Unit) ⊕ (Fin 2 ⊕ X₂')), ∃ eY : Y ≃ ((Y₁' ⊕ Fin 2) ⊕ (Unit ⊕ Y₂')),
        let M₀ := BinaryMatroid.threeSum
            ⟨M₁.cast (by subst hX₁ hY₁; rfl), hX₁ ▸ hY₁ ▸ B₁, (by subst hX₁ hY₁; convert M₁.hB)⟩
            ⟨M₂.cast (by subst hX₂ hY₂; rfl), hX₂ ▸ hY₂ ▸ B₂, (by subst hX₂ hY₂; convert M₂.hB)⟩
        M = M₀.fst.mapEquiv eX eY ∧ M₀.snd

/-- Any 1-sum of regular matroids is a regular matroid. -/
noncomputable
def BinaryMatroid.Is1sum.toRegular {M : BinaryMatroid X Y} {M₁ : RegularMatroid X₁ Y₁} {M₂ : RegularMatroid X₂ Y₂}
    (hM : M.Is1sum M₁.toBinaryMatroid M₂.toBinaryMatroid) :
    RegularMatroid X Y where
  toBinaryMatroid := M
  A := sorry
  hA := sorry
  hBA := sorry

/-- Any 2-sum of regular matroids is a regular matroid. -/
noncomputable
def BinaryMatroid.Is2sum.toRegular {M : BinaryMatroid X Y} {M₁ : RegularMatroid X₁ Y₁} {M₂ : RegularMatroid X₂ Y₂}
    (hM : M.Is2sum M₁.toBinaryMatroid M₂.toBinaryMatroid) :
    RegularMatroid X Y where
  toBinaryMatroid := M
  A := sorry
  hA := sorry
  hBA := sorry

/-- Any 3-sum of regular matroids is a regular matroid. -/
noncomputable
def BinaryMatroid.Is3sum.toRegular {M : BinaryMatroid X Y} {M₁ : RegularMatroid X₁ Y₁} {M₂ : RegularMatroid X₂ Y₂}
    (hM : M.Is3sum M₁.toBinaryMatroid M₂.toBinaryMatroid) :
    RegularMatroid X Y where
  toBinaryMatroid := M
  A := sorry
  hA := sorry
  hBA := sorry
