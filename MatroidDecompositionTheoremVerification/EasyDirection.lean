import MatroidDecompositionTheoremVerification.ForMathlib.MatrixTU

open scoped Matrix

/-- The finite field on two elements. -/
abbrev Z2 : Type := ZMod 2

/-- Given matrix `B`, is the set of columns `S` in the (standard) representation [`1` | `B`] `Z2`-independent? -/
def Matrix.IndepCols {α : Type} [DecidableEq α] {X Y : Set α} [∀ x, Decidable (x ∈ X)] [∀ y, Decidable (y ∈ Y)]
    (B : Matrix X Y Z2) (S : Set α) :
    Prop :=
  ∃ hs : S ⊆ X ∪ Y,
    LinearIndependent Z2
      ((Matrix.fromColumns 1 B).submatrix id
        (fun s : S =>
          if hsX : s.val ∈ X then Sum.inl ⟨s, hsX⟩ else
          if hsY : s.val ∈ Y then Sum.inr ⟨s, hsY⟩ else
          ((hs s.property).elim hsX hsY).elim :
        S → X ⊕ Y)
      ).transpose
/-
/-- The empty set of columns in linearly independent. -/
theorem Matrix.IndepCols_empty (B : Matrix X Y Z2) : B.IndepCols ∅ := by
  sorry

/-- A subset of a linearly independent set of columns in linearly independent. -/
theorem Matrix.IndepCols_subset (B : Matrix X Y Z2) (I J : Set α) (hBJ : B.IndepCols J) (hIJ : I ⊆ J) :
    B.IndepCols I := by
  sorry

/-- A nonmaximal linearly independent set of columns can be augmented with another linearly independent column. -/
theorem Matrix.IndepCols_aug (B : Matrix X Y Z2) (I J : Set α)
    (hBI : B.IndepCols I) (nonmax : ¬Maximal B.IndepCols I) (hBJ : Maximal B.IndepCols J) :
    ∃ x ∈ J \ I, B.IndepCols (insert x I) := by
  sorry

/-- Any set of columns has the maximal subset property. -/
theorem Matrix.IndepCols_maximal (B : Matrix X Y Z2) (S : Set α) :
    Matroid.ExistsMaximalSubsetProperty B.IndepCols S := by
  sorry

/-- Binary matroid generated by its standard representation matrix. -/
def Matrix.toIndepMatroid (B : Matrix X Y Z2) : IndepMatroid α where
  E := X ∪ Y
  Indep := B.IndepCols
  indep_empty := B.IndepCols_empty
  indep_subset := B.IndepCols_subset
  indep_aug := B.IndepCols_aug
  indep_maximal S _ := B.IndepCols_maximal S
  subset_ground _ := Exists.fst

/-- Binary matroid on the ground set `(X ⊕ Y)`. -/
structure BinaryMatroid (X Y : Set α) [∀ x, Decidable (x ∈ X)] [∀ y, Decidable (y ∈ Y)]
  extends IndepMatroid α where
    hXY : Disjoint X Y
    B : Matrix X Y Z2
    hB : B.toIndepMatroid = toIndepMatroid
-/
/-- Binary matroid on the ground set `(X ∪ Y)`. -/
structure BinaryMatroid (α : Type) [DecidableEq α]
  extends Matroid α where
    X : Set α
    Y : Set α
    decidmemX : ∀ x, Decidable (x ∈ X)
    decidmemY : ∀ y, Decidable (y ∈ Y)
    hXY : Disjoint X Y
    hE : X ∪ Y = E
    B : Matrix X Y Z2
    hB : B.IndepCols = Indep

variable {α : Type} [DecidableEq α]

/-- Regular matroid on the ground set `(X ⊕ Y)`. -/
def BinaryMatroid.IsRegular (M : BinaryMatroid α) : Prop :=
  ∃ B' : Matrix M.X M.Y ℚ, -- signed version of `B`
    (Matrix.fromColumns (1 : Matrix M.X M.X ℚ) B').TU ∧ -- the matrix is totally unimodular
    ∀ i : M.X, ∀ j : M.Y, if M.B i j = 0 then B' i j = 0 else B' i j = 1 ∨ B' i j = -1 -- `B'` matches `B`

section matrix_level

variable {X₁ Y₁ : Set α} {X₂ Y₂ : Set α} {β : Type} [Field β]

/-- Matrix-level 1-sum for matroids defined by their standard representation matrices. -/
abbrev Matrix.oneSumComposition (A₁ : Matrix X₁ Y₁ β) (A₂ : Matrix X₂ Y₂ β) :
    Matrix (X₁ ⊕ X₂) (Y₁ ⊕ Y₂) β :=
  Matrix.fromBlocks A₁ 0 0 A₂

/-- Matrix-level 2-sum for matroids defined by their standard representation matrices; does not check legitimacy. -/
abbrev Matrix.twoSumComposition (A₁ : Matrix X₁ Y₁ β) (x : Y₁ → β) (A₂ : Matrix X₂ Y₂ β) (y : X₂ → β) :
    Matrix (X₁ ⊕ X₂) (Y₁ ⊕ Y₂) β :=
  Matrix.fromBlocks A₁ 0 (fun i j => y i * x j) A₂

/-- Matrix-level 3-sum for matroids defined by their standard representation matrices; does not check legitimacy. -/
noncomputable abbrev Matrix.threeSumComposition (A₁ : Matrix X₁ (Y₁ ⊕ Fin 2) β) (A₂ : Matrix (Fin 2 ⊕ X₂) Y₂ β)
    (z₁ : Y₁ → β) (z₂ : X₂ → β)
    (D : Matrix (Fin 2) (Fin 2) β) (D₁ : Matrix (Fin 2) Y₁ β) (D₂ : Matrix X₂ (Fin 2) β) :
    Matrix ((X₁ ⊕ Unit) ⊕ (Fin 2 ⊕ X₂)) ((Y₁ ⊕ Fin 2) ⊕ (Unit ⊕ Y₂)) β :=
  let D₁₂ : Matrix X₂ Y₁ β := D₂ * D⁻¹ * D₁
  Matrix.fromBlocks
    (Matrix.fromRows A₁ (Matrix.row Unit (Sum.elim z₁ ![1, 1]))) 0
    (Matrix.fromBlocks D₁ D D₁₂ D₂) (Matrix.fromColumns (Matrix.col Unit (Sum.elim ![1, 1] z₂)) A₂)

end matrix_level

/-- Matroid-level (independent sets) 1-sum for matroids defined by their standard representation matrices. -/
def BinaryMatroid.oneSum {M₁ : BinaryMatroid α} {M₂ : BinaryMatroid α}
    (hX : Disjoint M₁.X M₂.X) (hY : Disjoint M₁.Y M₂.Y) (hXY : Disjoint M₁.X M₂.Y) (hYX : Disjoint M₁.Y M₂.X) :
    BinaryMatroid α where
  toMatroid := sorry
  X := M₁.X ∪ M₂.X
  Y := M₁.Y ∪ M₂.Y
  decidmemX := by
    have := M₁.decidmemX
    have := M₂.decidmemX
    exact (Set.decidableUnion M₁.X M₂.X ·)
  decidmemY := by
    have := M₁.decidmemY
    have := M₂.decidmemY
    exact (Set.decidableUnion M₁.Y M₂.Y ·)
  hXY := by
    rw [Set.disjoint_union_right, Set.disjoint_union_left, Set.disjoint_union_left]
    exact ⟨⟨M₁.hXY, hYX.symm⟩, ⟨hXY, M₂.hXY⟩⟩
  B := fun i j =>
    have := M₁.decidmemX
    have := M₁.decidmemY
    have := M₂.decidmemX
    have := M₂.decidmemY
    Matrix.oneSumComposition M₁.B M₂.B (
      if hi₁ : i.val ∈ M₁.X then Sum.inl ⟨i, hi₁⟩ else
      if hi₂ : i.val ∈ M₂.X then Sum.inr ⟨i, hi₂⟩ else
      (i.property.elim hi₁ hi₂).elim
    ) (
      if hj₁ : j.val ∈ M₁.Y then Sum.inl ⟨j, hj₁⟩ else
      if hj₂ : j.val ∈ M₂.Y then Sum.inr ⟨j, hj₂⟩ else
      (j.property.elim hj₁ hj₂).elim
    )
  hE := sorry--rfl
  hB := sorry--rfl

/-- Matroid-level 2-sum for matroids defined by their standard representation matrices; now checks legitimacy. -/
def BinaryMatroid.twoSum (M₁ : BinaryMatroid α) (M₂ : BinaryMatroid α)
    {a : α} (hY₁ : a ∉ M₁.Y) (hX₂ : a ∉ M₂.X) (ha : M₁.X ∩ M₂.Y = {a}) :
    -- TODO require disjointness of "everything else", then `hY₁` and `hX₂` may be removed
    BinaryMatroid α × Prop :=
  have := M₁.decidmemX
  have := M₁.decidmemY
  have := M₂.decidmemX
  have := M₂.decidmemY
  let A₁ : Matrix (M₁.X \ {a} : Set α) M₁.Y Z2 := fun i j => M₁.B ⟨i.val, Set.mem_of_mem_diff i.property⟩ j -- the top submatrix of `B₁`
  let A₂ : Matrix M₂.X (M₂.Y \ {a} : Set α) Z2 := fun i j => M₂.B i ⟨j.val, Set.mem_of_mem_diff j.property⟩ -- the right submatrix of `B₂`
  let x : M₁.Y → Z2 := M₁.B ⟨a, Set.mem_of_mem_inter_left (by rw [ha]; rfl)⟩ -- the bottom row of the matrix `B₁`
  let y : M₂.X → Z2 := (M₂.B · ⟨a, Set.mem_of_mem_inter_right (by rw [ha]; rfl)⟩) -- the leftmost column of the matrix `B₂`
  ⟨
    ⟨sorry, (M₁.X \ {a} : Set α) ∪ M₂.X, (M₁.Y ∪ (M₂.Y \ {a} : Set α)), sorry, sorry, sorry, sorry, fun i j =>
      Matrix.twoSumComposition A₁ x A₂ y (
        if hi₁ : i.val ∈ M₁.X \ {a} then Sum.inl ⟨i, hi₁⟩ else
        if hi₂ : i.val ∈ M₂.X then Sum.inr ⟨i, hi₂⟩ else
        (i.property.elim hi₁ hi₂).elim
      ) (
        if hj₁ : j.val ∈ M₁.Y then Sum.inl ⟨j, hj₁⟩ else
        if hj₂ : j.val ∈ M₂.Y \ {a} then Sum.inr ⟨j, hj₂⟩ else
        (j.property.elim hj₁ hj₂).elim
      ), sorry⟩,
    x ≠ 0 ∧ y ≠ 0
  ⟩

/-
/-- Matroid-level 3-sum for matroids defined by their standard representation matrices; now checks legitimacy. -/
noncomputable def BinaryMatroid.threeSum
    (M₁ : BinaryMatroid ((X₁ ⊕ Unit) ⊕ Fin 2) ((Y₁ ⊕ Fin 2) ⊕ Unit))
    (M₂ : BinaryMatroid (Unit ⊕ (Fin 2 ⊕ X₂)) (Fin 2 ⊕ (Unit ⊕ Y₂))) :
    BinaryMatroid ((X₁ ⊕ Unit) ⊕ (Fin 2 ⊕ X₂)) ((Y₁ ⊕ Fin 2) ⊕ (Unit ⊕ Y₂)) × Prop :=
  let B₁ := M₁.B -- the standard representation matrix of `M₁`
  let B₂ := M₂.B -- the standard representation matrix of `M₂`
  let A₁ : Matrix X₁ (Y₁ ⊕ Fin 2) Z2 := ((B₁ ∘ .inl ∘ .inl) · ∘ .inl) -- the top left submatrix
  let A₂ : Matrix (Fin 2 ⊕ X₂) Y₂ Z2 := ((B₂ ∘ .inr) · ∘ .inr ∘ .inr) -- the bottom right submatrix
  let z₁ : Y₁ → Z2 := fun j => B₁ (.inl (.inr ())) (.inl (.inl j)) -- the middle left "row vector"
  let z₂ : X₂ → Z2 := fun i => B₂ (.inr (.inr i)) (.inr (.inl ())) -- the bottom middle "column vector"
  let D_₁ : Matrix (Fin 2) (Fin 2) Z2 := fun i j => B₁ (.inr i) (.inl (.inr j)) -- the bottom middle 2x2 submatrix
  let D_₂ : Matrix (Fin 2) (Fin 2) Z2 := fun i j => B₂ (.inr (.inl i)) (.inl j) -- the middle left 2x2 submatrix
  let D₁ : Matrix (Fin 2) Y₁ Z2 := fun i j => B₁ (.inr i) (.inl (.inl j)) -- the bottom left submatrix
  let D₂ : Matrix X₂ (Fin 2) Z2 := fun i j => B₂ (.inr (.inr i)) (.inl j) -- the bottom left submatrix
  ⟨
    ⟨_, Matrix.threeSumComposition A₁ A₂ z₁ z₂ D_₁ D₁ D₂, rfl⟩,
    IsUnit D_₁ ∧ D_₁ = D_₂ -- the matrix `D_₁ = D_₂` (called D-bar in the book) is invertible
  ⟩
-/
/-- Matroid `M` is a result of 1-summing `M₁` and `M₂` (should be equivalent to direct sums). -/
def BinaryMatroid.Is1sum (M : BinaryMatroid α) (M₁ : BinaryMatroid α) (M₂ : BinaryMatroid α) : Prop :=
  ∃ hX : Disjoint M₁.X M₂.X, ∃ hY : Disjoint M₁.Y M₂.Y, ∃ hXY : Disjoint M₁.X M₂.Y, ∃ hYX : Disjoint M₁.Y M₂.X,
    M = BinaryMatroid.oneSum hX hY hXY hYX
/-
/-- Matroid `M` is a result of 1-summing `M₁` and `M₂` (should be equivalent to direct sums). -/
def BinaryMatroid.Is1sum (M : BinaryMatroid (X₁ ∪ X₂) (Y₁ ∪ Y₂)) (M₁ : BinaryMatroid X₁ Y₁) (M₂ : BinaryMatroid X₂ Y₂) : Prop :=
  (Disjoint X₁ X₂ ∧ Disjoint Y₁ Y₂) ∧
    ∀ i j, M.B i j =
      Matrix.oneSumComposition M₁.B M₂.B (
        if hi₁ : i.val ∈ X₁ then Sum.inl ⟨i, hi₁⟩ else
        if hi₂ : i.val ∈ X₂ then Sum.inr ⟨i, hi₂⟩ else
        (i.property.elim hi₁ hi₂).elim
      ) (
        if hj₁ : j.val ∈ Y₁ then Sum.inl ⟨j, hj₁⟩ else
        if hj₂ : j.val ∈ Y₂ then Sum.inr ⟨j, hj₂⟩ else
        (j.property.elim hj₁ hj₂).elim
      )
-/
/-- Matroid `M` is a result of 2-summing `M₁` and `M₂` in some way. -/
def BinaryMatroid.Is2sum (M : BinaryMatroid α) (M₁ : BinaryMatroid α) (M₂ : BinaryMatroid α) : Prop :=
  (Disjoint M₁.X M₂.X ∧ Disjoint M₁.Y M₂.Y) ∧ -- TODO some more disjointness
    ∃ a : α, ∃ hY₁ : a ∉ M₁.Y, ∃ hX₂ : a ∉ M₂.X, ∃ ha : M₁.X ∩ M₂.Y = {a},
      let M₀ := BinaryMatroid.twoSum M₁ M₂ hY₁ hX₂ ha
      M = M₀.fst ∧ M₀.snd
/-
/-- Matroid `M` is a result of 3-summing `M₁` and `M₂` in some way. -/
def BinaryMatroid.Is3sum (M : BinaryMatroid X Y) (M₁ : BinaryMatroid X₁ Y₁) (M₂ : BinaryMatroid X₂ Y₂) : Prop :=
  let B₁ := M₁.B -- the standard representation matrix of `M₁`
  let B₂ := M₂.B -- the standard representation matrix of `M₂`
  ∃ X₁' Y₁' : Type, ∃ _ : DecidableEq X₁', ∃ _ : DecidableEq Y₁', -- indexing types for the shared parts
  ∃ X₂' Y₂' : Type, ∃ _ : DecidableEq X₂', ∃ _ : DecidableEq Y₂', -- indexing types for the shared parts
    ∃ hX₁ : X₁ = ((X₁' ⊕ Unit) ⊕ Fin 2), ∃ hY₁ : Y₁ = ((Y₁' ⊕ Fin 2) ⊕ Unit),
    ∃ hX₂ : X₂ = (Unit ⊕ (Fin 2 ⊕ X₂')), ∃ hY₂ : Y₂ = (Fin 2 ⊕ (Unit ⊕ Y₂')),
      ∃ eX : X ≃ ((X₁' ⊕ Unit) ⊕ (Fin 2 ⊕ X₂')), ∃ eY : Y ≃ ((Y₁' ⊕ Fin 2) ⊕ (Unit ⊕ Y₂')),
        let M₀ := BinaryMatroid.threeSum
            ⟨M₁.cast (by subst hX₁ hY₁; rfl), hX₁ ▸ hY₁ ▸ B₁, (by subst hX₁ hY₁; convert M₁.hB)⟩
            ⟨M₂.cast (by subst hX₂ hY₂; rfl), hX₂ ▸ hY₂ ▸ B₂, (by subst hX₂ hY₂; convert M₂.hB)⟩
        M = M₀.fst.mapEquiv eX eY ∧ M₀.snd
-/
/-- Any 1-sum of regular matroids is a regular matroid. -/
theorem BinaryMatroid.Is1sum.isRegular {M : BinaryMatroid α} {M₁ : BinaryMatroid α} {M₂ : BinaryMatroid α}
    (hM : M.Is1sum M₁ M₂) (hM₁ : M₁.IsRegular) (hM₂ : M₂.IsRegular) :
    M.IsRegular := by
  obtain ⟨eX, eY, hMXY⟩ := hM
  obtain ⟨B₁, hB₁, hBB₁⟩ := hM₁
  obtain ⟨B₂, hB₂, hBB₂⟩ := hM₂
  let B' := Matrix.oneSumComposition B₁ B₂
  have hB' : B'.TU
  · apply Matrix.fromBlocks_TU
    · rwa [Matrix.TU_glue_iff] at hB₁
    · rwa [Matrix.TU_glue_iff] at hB₂
  sorry

/-- Any 2-sum of regular matroids is a regular matroid. -/
theorem BinaryMatroid.Is2sum.isRegular {a : α} {M : BinaryMatroid α} {M₁ : BinaryMatroid α} {M₂ : BinaryMatroid α}
    (hM : M.Is2sum M₁ M₂) (hM₁ : M₁.IsRegular) (hM₂ : M₂.IsRegular) :
    M.IsRegular := by
  obtain ⟨eX, eY, hMXY⟩ := hM
  obtain ⟨B₁', hB₁, hBB₁⟩ := hM₁
  obtain ⟨B₂', hB₂, hBB₂⟩ := hM₂
  sorry
/-
/-- Any 3-sum of regular matroids is a regular matroid. -/
theorem BinaryMatroid.Is3sum.isRegular {M : BinaryMatroid X Y} {M₁ : BinaryMatroid X₁ Y₁} {M₂ : BinaryMatroid X₂ Y₂}
    (hM : M.Is3sum M₁ M₂) (hM₁ : M₁.IsRegular) (hM₂ : M₂.IsRegular) :
    M.IsRegular := by
  obtain ⟨eX, eY, hMXY⟩ := hM
  obtain ⟨B₁', hB₁, hBB₁⟩ := hM₁
  obtain ⟨B₂', hB₂, hBB₂⟩ := hM₂
  sorry
-/
