import Mathlib

open scoped Matrix

/-- The finite field on two elements. -/
abbrev Z2 : Type := Fin 2

variable {X Y : Type} [DecidableEq X] [DecidableEq Y]

/-- Given matrix `B` is the set of columns `S` in the (standard) representation [I | B] `Z2`-independent? -/
def Matrix.IndepCols (B : Matrix X Y Z2) (S : Set (X ⊕ Y)) : Prop :=
  LinearIndependent Z2 ((Matrix.fromColumns 1 B).submatrix id ((↑) : S → X ⊕ Y)).transpose

/-- The empty set of columns in linearly independent. -/
theorem Matrix.IndepCols_empty (B : Matrix X Y Z2) : B.IndepCols ∅ := by
  sorry

/-- A subset of a linearly independent set of columns in linearly independent. -/
theorem Matrix.IndepCols_subset (B : Matrix X Y Z2) (I J : Set (X ⊕ Y)) (hBJ : B.IndepCols J) (hIJ : I ⊆ J) :
    B.IndepCols I := by
  sorry

/-- A nonmaximal linearly independent set of columns can be augmented with another linearly independent column. -/
theorem Matrix.IndepCols_aug (B : Matrix X Y Z2) (I J : Set (X ⊕ Y)) -- `J` is a base
    (hBI : B.IndepCols I) (nonmax : ¬Maximal B.IndepCols I) (hBJ : Maximal B.IndepCols J) :
    ∃ x ∈ J \ I, B.IndepCols (insert x I) := by
  sorry

/-- Any set of columns has the maximal subset property. -/
theorem Matrix.IndepCols_maximal (B : Matrix X Y Z2) (S : Set (X ⊕ Y)) :
    Matroid.ExistsMaximalSubsetProperty B.IndepCols S := by
  sorry

/-- Binary matroid generated by its standard representation matrix. -/
def Matrix.toIndepMatroid (B : Matrix X Y Z2) : IndepMatroid (X ⊕ Y) where
  E := Set.univ
  Indep := B.IndepCols
  indep_empty := B.IndepCols_empty
  indep_subset := B.IndepCols_subset
  indep_aug := B.IndepCols_aug
  indep_maximal S _ := B.IndepCols_maximal S
  subset_ground := fun _ _ _ _ => trivial

/-- Binary matroid on the ground set `(X ⊕ Y)`. -/
structure BinaryMatroid (X Y : Type) [DecidableEq X] [DecidableEq Y]
  extends IndepMatroid (X ⊕ Y) where
    B : Matrix X Y Z2
    hB : B.toIndepMatroid = toIndepMatroid

/-- Is the matrix `A` totally unimodular? -/
def Matrix.TU (A : Matrix X Y ℚ) : Prop :=
  ∀ k : ℕ, ∀ f : Fin k → X, ∀ g : Fin k → Y, f.Injective → g.Injective →
    (A.submatrix f g).det = 0 ∨
    (A.submatrix f g).det = 1 ∨
    (A.submatrix f g).det = -1

lemma Matrix.TU_iff (A : Matrix X Y ℚ) : A.TU ↔
    ∀ k : ℕ, ∀ f : Fin k → X, ∀ g : Fin k → Y,
      (A.submatrix f g).det = 0 ∨
      (A.submatrix f g).det = 1 ∨
      (A.submatrix f g).det = -1
    := by
  constructor <;> intro hA
  · intro k f g
    if hf : f.Injective then
      if hg : g.Injective then
        exact hA k f g hf hg
      else
        left
        unfold Function.Injective at hg
        push_neg at hg
        obtain ⟨i, j, hqij, hij⟩ := hg
        apply Matrix.det_zero_of_column_eq
        · exact hij
        intro
        simp [hqij]
    else
      left
      unfold Function.Injective at hf
      push_neg at hf
      obtain ⟨i, j, hpij, hij⟩ := hf
      apply Matrix.det_zero_of_row_eq
      · exact hij
      show (A (f i)) ∘ (g ·) = (A (f j)) ∘ (g ·)
      rw [hpij]
  · intros _ _ _ _ _
    apply hA

lemma Matrix.mapEquiv_TU {X' Y' : Type} [DecidableEq X'] [DecidableEq Y']
    (A : Matrix X Y ℚ) (eX : X' ≃ X) (eY : Y' ≃ Y) :
    Matrix.TU ((A · ∘ eY) ∘ eX) ↔ A.TU := by
  rw [Matrix.TU_iff, Matrix.TU_iff]
  constructor <;> intro hA k f g
  · simpa [Matrix.submatrix] using hA k (eX.symm ∘ f) (eY.symm ∘ g)
  · simpa [Matrix.submatrix] using hA k (eX ∘ f) (eY ∘ g)

lemma Matrix.submatrix_TU {A : Matrix X Y ℚ} (hA : A.TU) (k : ℕ) (f : Fin k → X) (g : Fin k → Y) :
    (A.submatrix f g).TU := by
  intro _ _ _ _ _
  rw [Matrix.submatrix_submatrix]
  rw [Matrix.TU_iff] at hA
  apply hA

omit [DecidableEq X] [DecidableEq Y] in
lemma Matrix.transpose_TU {A : Matrix X Y ℚ} (hA : A.TU) : Aᵀ.TU := by
  intro _ _ _ _ _
  simp only [←Matrix.transpose_submatrix, Matrix.det_transpose]
  apply hA <;> assumption

lemma Matrix.TU_glue_iff (A : Matrix X Y ℚ) : (Matrix.fromColumns (1 : Matrix X X ℚ) A).TU ↔ A.TU := by
  rw [Matrix.TU_iff, Matrix.TU_iff]
  constructor <;> intro hA k f g
  · exact hA k f (Sum.inr ∘ g)
  · sorry

/-- Regular matroid on the ground set `(X ⊕ Y)`. -/
def BinaryMatroid.IsRegular (M : BinaryMatroid X Y) : Prop :=
  ∃ B' : Matrix X Y ℚ, -- signed version of `B`
    (Matrix.fromColumns (1 : Matrix X X ℚ) B').TU ∧ -- the matrix is totally unimodular
    ∀ i : X, ∀ j : Y, if M.B i j = 0 then B' i j = 0 else B' i j = 1 ∨ B' i j = -1 -- `B'` matches `B`

/-- Matroid casting, i.e., renaming the type without changing the elements; implemented for independent sets. -/
def IndepMatroid.cast (M : IndepMatroid X) (hXY : X = Y) : IndepMatroid Y where
  E := hXY ▸ M.E
  Indep := hXY ▸ M.Indep
  indep_empty := by subst hXY; exact M.indep_empty
  indep_subset := by subst hXY; exact M.indep_subset
  indep_aug := by subst hXY; exact M.indep_aug
  indep_maximal := by subst hXY; exact M.indep_maximal
  subset_ground := by subst hXY; exact M.subset_ground

/-- Matroid isomorphism, i.e., renaming the elements (the type changes as well); implemented for independent sets. -/
def IndepMatroid.mapEquiv (M : IndepMatroid X) (eYX : Y ≃ X) : IndepMatroid Y where
  E := eYX.symm '' M.E
  Indep I := ∃ I₀, M.Indep I₀ ∧ I = eYX.symm '' I₀
  indep_empty := ⟨∅, M.indep_empty, by simp⟩
  indep_subset I J hI hJ := by
    refine ⟨eYX '' I, ?_, by simp [Equiv.eq_image_iff_symm_image_eq eYX]⟩
    obtain ⟨I', hIJ⟩ := hI
    have := M.indep_subset (I := eYX '' I) (J := eYX '' J)
    simp_all
  indep_aug := by sorry
  indep_maximal I := by sorry
  subset_ground I hI := by have := M.subset_ground (eYX '' I); aesop

def BinaryMatroid.mapEquiv {X' Y' : Type} [DecidableEq X'] [DecidableEq Y']
    (M : BinaryMatroid X Y) (eX : X' ≃ X) (eY : Y' ≃ Y) : BinaryMatroid X' Y' where
  toIndepMatroid := M.toIndepMatroid.mapEquiv (Equiv.sumCongr eX eY)
  B := fun i j => M.B (eX i) (eY j)
  hB := by sorry

variable {X₁ X₂ Y₁ Y₂ : Type}

lemma Matrix.submatrix_fromBlocks {α : Type*} {ι ρ : Type} (f : ι → X₁ ⊕ X₂) (g : ρ → Y₁ ⊕ Y₂)
    (A₁₁ : Matrix X₁ Y₁ α) (A₁₂ : Matrix X₁ Y₂ α) (A₂₁ : Matrix X₂ Y₁ α) (A₂₂ : Matrix X₂ Y₂ α) :
    (Matrix.fromBlocks A₁₁ A₁₂ A₂₁ A₂₂).submatrix f g =
    (fun (i : ι) (j : ρ) =>
      match f i with
      | .inl i₁ =>
        match g j with
        | .inl j₁ => A₁₁ i₁ j₁
        | .inr j₂ => A₁₂ i₁ j₂
      | .inr i₂ =>
        match g j with
        | .inl j₁ => A₂₁ i₂ j₁
        | .inr j₂ => A₂₂ i₂ j₂
    ) := by
  aesop

lemma todo {α β₁ β₂ : Type} (f : α → β₁ ⊕ β₂) :
    ∃ α₁ α₂ : Type, ∃ e : α ≃ α₁ ⊕ α₂, ∃ f₁ : α₁ → β₁, ∃ f₂ : α₂ → β₂,
      ∀ i : α, f i = (Sum.elim (Sum.inl ∘ f₁) (Sum.inr ∘ f₂)) (e i) := by
  classical
  use { a : α // ∃ b₁ : β₁, f a = Sum.inl b₁ }
  use { a : α // ∃ b₂ : β₂, f a = Sum.inr b₂ }
  let e' : α → { a : α // ∃ b₁ : β₁, f a = Sum.inl b₁ } ⊕ { a : α // ∃ b₂ : β₂, f a = Sum.inr b₂ } :=
    fun a : α =>
      if hb₁ : ∃ b₁ : β₁, f a = Sum.inl b₁ then sorry else sorry
  sorry

lemma Matrix.fromBlocks_TU {A₁ : Matrix X₁ Y₁ ℚ} {A₂ : Matrix X₂ Y₂ ℚ} (hA₁ : A₁.TU) (hA₂ : A₂.TU) :
    (Matrix.fromBlocks A₁ 0 0 A₂).TU := by
  intro k f g hf hg
  obtain ⟨ι₁, ι₂, eι, f₁, f₂, hf⟩ := todo f
  obtain ⟨ρ₁, ρ₂, eρ, g₁, g₂, hg⟩ := todo g
  have todo_extract :
    (Matrix.fromBlocks A₁ 0 0 A₂).submatrix f g =
    ((Matrix.fromBlocks
      (A₁.submatrix f₁ g₁) 0
      0 (A₂.submatrix f₂ g₂)
    ) · ∘ eρ) ∘ eι
  · ext i j
    cases hi : eι i <;> cases hj : eρ j <;> simp [hi, hj] <;> aesop
  rw [todo_extract]
  --rw [Matrix.det_fromBlocks_zero₂₁]
  sorry

variable [DecidableEq X₁] [DecidableEq Y₁] [DecidableEq X₂] [DecidableEq Y₂]

/-- Matrix-level 1-sum for matroids defined by their standard representation matrices. -/
abbrev Matrix.oneSumComposition (A₁ : Matrix X₁ Y₁ Z2) (A₂ : Matrix X₂ Y₂ Z2) :
    Matrix (X₁ ⊕ X₂) (Y₁ ⊕ Y₂) Z2 :=
  Matrix.fromBlocks A₁ 0 0 A₂

/-- Matrix-level 2-sum for matroids defined by their standard representation matrices; does not check legitimacy. -/
abbrev Matrix.twoSumComposition (A₁ : Matrix X₁ Y₁ Z2) (x : Y₁ → Z2) (A₂ : Matrix X₂ Y₂ Z2) (y : X₂ → Z2) :
    Matrix (X₁ ⊕ X₂) (Y₁ ⊕ Y₂) Z2 :=
  Matrix.fromBlocks A₁ 0 (fun i j => y i * x j) A₂

/-- Matrix-level 3-sum for matroids defined by their standard representation matrices; does not check legitimacy. -/
noncomputable abbrev Matrix.threeSumComposition (A₁ : Matrix X₁ (Y₁ ⊕ Fin 2) Z2) (A₂ : Matrix (Fin 2 ⊕ X₂) Y₂ Z2)
    (z₁ : Y₁ → Z2) (z₂ : X₂ → Z2)
    (D : Matrix (Fin 2) (Fin 2) Z2) (D₁ : Matrix (Fin 2) Y₁ Z2) (D₂ : Matrix X₂ (Fin 2) Z2) :
    Matrix ((X₁ ⊕ Unit) ⊕ (Fin 2 ⊕ X₂)) ((Y₁ ⊕ Fin 2) ⊕ (Unit ⊕ Y₂)) Z2 :=
  let D₁₂ : Matrix X₂ Y₁ Z2 := D₂ * D⁻¹ * D₁
  Matrix.fromBlocks
    (Matrix.fromRows A₁ (Matrix.row Unit (Sum.elim z₁ ![1, 1]))) 0
    (Matrix.fromBlocks D₁ D D₁₂ D₂) (Matrix.fromColumns (Matrix.col Unit (Sum.elim ![1, 1] z₂)) A₂)

/-- Matroid-level (independent sets) 1-sum for matroids defined by their standard representation matrices. -/
def BinaryMatroid.oneSum (M₁ : BinaryMatroid X₁ Y₁) (M₂ : BinaryMatroid X₂ Y₂) :
    BinaryMatroid (X₁ ⊕ X₂) (Y₁ ⊕ Y₂) :=
  ⟨_, Matrix.oneSumComposition M₁.B M₂.B, rfl⟩

/-- Matroid-level 2-sum for matroids defined by their standard representation matrices; now checks legitimacy. -/
def BinaryMatroid.twoSum (M₁ : BinaryMatroid (X₁ ⊕ Unit) Y₁) (M₂ : BinaryMatroid X₂ (Unit ⊕ Y₂)) :
    BinaryMatroid (X₁ ⊕ X₂) (Y₁ ⊕ Y₂) × Prop :=
  let B₁ := M₁.B -- the standard representation matrix of `M₁`
  let B₂ := M₂.B -- the standard representation matrix of `M₂`
  let A₁ : Matrix X₁ Y₁ Z2 := B₁ ∘ .inl -- the top submatrix of `B₁`
  let A₂ : Matrix X₂ Y₂ Z2 := (B₂ · ∘ .inr) -- the right submatrix of `B₂`
  let x : Y₁ → Z2 := (B₁ ∘ .inr) () -- the bottom row of the matrix `B₁`
  let y : X₂ → Z2 := ((B₂ · ∘ .inl) · ()) -- the leftmost column of the matrix `B₂`
  ⟨
    ⟨_, Matrix.twoSumComposition A₁ x A₂ y, rfl⟩,
    x ≠ 0 ∧ y ≠ 0
  ⟩

/-- Matroid-level 3-sum for matroids defined by their standard representation matrices; now checks legitimacy. -/
noncomputable def BinaryMatroid.threeSum
    (M₁ : BinaryMatroid ((X₁ ⊕ Unit) ⊕ Fin 2) ((Y₁ ⊕ Fin 2) ⊕ Unit))
    (M₂ : BinaryMatroid (Unit ⊕ (Fin 2 ⊕ X₂)) (Fin 2 ⊕ (Unit ⊕ Y₂))) :
    BinaryMatroid ((X₁ ⊕ Unit) ⊕ (Fin 2 ⊕ X₂)) ((Y₁ ⊕ Fin 2) ⊕ (Unit ⊕ Y₂)) × Prop :=
  let B₁ := M₁.B -- the standard representation matrix of `M₁`
  let B₂ := M₂.B -- the standard representation matrix of `M₂`
  let A₁ : Matrix X₁ (Y₁ ⊕ Fin 2) Z2 := ((B₁ ∘ .inl ∘ .inl) · ∘ .inl) -- the top left submatrix
  let A₂ : Matrix (Fin 2 ⊕ X₂) Y₂ Z2 := ((B₂ ∘ .inr) · ∘ .inr ∘ .inr) -- the bottom right submatrix
  let z₁ : Y₁ → Z2 := fun j => B₁ (.inl (.inr ())) (.inl (.inl j)) -- the middle left "row vector"
  let z₂ : X₂ → Z2 := fun i => B₂ (.inr (.inr i)) (.inr (.inl ())) -- the bottom middle "column vector"
  let D_₁ : Matrix (Fin 2) (Fin 2) Z2 := fun i j => B₁ (.inr i) (.inl (.inr j)) -- the bottom middle 2x2 submatrix
  let D_₂ : Matrix (Fin 2) (Fin 2) Z2 := fun i j => B₂ (.inr (.inl i)) (.inl j) -- the middle left 2x2 submatrix
  let D₁ : Matrix (Fin 2) Y₁ Z2 := fun i j => B₁ (.inr i) (.inl (.inl j)) -- the bottom left submatrix
  let D₂ : Matrix X₂ (Fin 2) Z2 := fun i j => B₂ (.inr (.inr i)) (.inl j) -- the bottom left submatrix
  ⟨
    ⟨_, Matrix.threeSumComposition A₁ A₂ z₁ z₂ D_₁ D₁ D₂, rfl⟩,
    IsUnit D_₁ ∧ D_₁ = D_₂ -- the matrix `D_₁ = D_₂` (called D-bar in the book) is invertible
  ⟩

/-- Matroid `M` is a result of 1-summing `M₁` and `M₂` (should be equivalent to direct sums). -/
def BinaryMatroid.Is1sum (M : BinaryMatroid X Y) (M₁ : BinaryMatroid X₁ Y₁) (M₂ : BinaryMatroid X₂ Y₂) : Prop :=
  ∃ eX : X ≃ (X₁ ⊕ X₂), ∃ eY : Y ≃ (Y₁ ⊕ Y₂),
    M = (BinaryMatroid.oneSum M₁ M₂).mapEquiv eX eY

/-- Matroid `M` is a result of 2-summing `M₁` and `M₂` in some way. -/
def BinaryMatroid.Is2sum (M : BinaryMatroid X Y) (M₁ : BinaryMatroid X₁ Y₁) (M₂ : BinaryMatroid X₂ Y₂) : Prop :=
  let B₁ := M₁.B -- the standard representation matrix of `M₁`
  let B₂ := M₂.B -- the standard representation matrix of `M₂`
  ∃ X' Y' : Type, ∃ _ : DecidableEq X', ∃ _ : DecidableEq Y', -- indexing types for the shared parts
    ∃ hX : X₁ = (X' ⊕ Unit), ∃ hY : Y₂ = (Unit ⊕ Y'), ∃ eX : X ≃ (X' ⊕ X₂), ∃ eY : Y ≃ (Y₁ ⊕ Y'),
      let M₀ := BinaryMatroid.twoSum
        ⟨M₁.cast (congr_arg (· ⊕ Y₁) hX), hX ▸ B₁, by subst hX; convert M₁.hB⟩
        ⟨M₂.cast (congr_arg (X₂ ⊕ ·) hY), hY ▸ B₂, by subst hY; convert M₂.hB⟩
      M = M₀.fst.mapEquiv eX eY ∧ M₀.snd

/-- Matroid `M` is a result of 3-summing `M₁` and `M₂` in some way. -/
def BinaryMatroid.Is3sum (M : BinaryMatroid X Y) (M₁ : BinaryMatroid X₁ Y₁) (M₂ : BinaryMatroid X₂ Y₂) : Prop :=
  let B₁ := M₁.B -- the standard representation matrix of `M₁`
  let B₂ := M₂.B -- the standard representation matrix of `M₂`
  ∃ X₁' Y₁' : Type, ∃ _ : DecidableEq X₁', ∃ _ : DecidableEq Y₁', -- indexing types for the shared parts
  ∃ X₂' Y₂' : Type, ∃ _ : DecidableEq X₂', ∃ _ : DecidableEq Y₂', -- indexing types for the shared parts
    ∃ hX₁ : X₁ = ((X₁' ⊕ Unit) ⊕ Fin 2), ∃ hY₁ : Y₁ = ((Y₁' ⊕ Fin 2) ⊕ Unit),
    ∃ hX₂ : X₂ = (Unit ⊕ (Fin 2 ⊕ X₂')), ∃ hY₂ : Y₂ = (Fin 2 ⊕ (Unit ⊕ Y₂')),
      ∃ eX : X ≃ ((X₁' ⊕ Unit) ⊕ (Fin 2 ⊕ X₂')), ∃ eY : Y ≃ ((Y₁' ⊕ Fin 2) ⊕ (Unit ⊕ Y₂')),
        let M₀ := BinaryMatroid.threeSum
            ⟨M₁.cast (by subst hX₁ hY₁; rfl), hX₁ ▸ hY₁ ▸ B₁, (by subst hX₁ hY₁; convert M₁.hB)⟩
            ⟨M₂.cast (by subst hX₂ hY₂; rfl), hX₂ ▸ hY₂ ▸ B₂, (by subst hX₂ hY₂; convert M₂.hB)⟩
        M = M₀.fst.mapEquiv eX eY ∧ M₀.snd

/-- Any 1-sum of regular matroids is a regular matroid. -/
theorem BinaryMatroid.Is1sum.isRegular {M : BinaryMatroid X Y} {M₁ : BinaryMatroid X₁ Y₁} {M₂ : BinaryMatroid X₂ Y₂}
    (hM : M.Is1sum M₁ M₂) (hM₁ : M₁.IsRegular) (hM₂ : M₂.IsRegular) :
    M.IsRegular := by
  obtain ⟨eX, eY, hMXY⟩ := hM
  dsimp only [BinaryMatroid.oneSum, BinaryMatroid.mapEquiv, Matrix.oneSumComposition] at hMXY
  obtain ⟨B₁', hB₁, hBB₁⟩ := hM₁
  obtain ⟨B₂', hB₂, hBB₂⟩ := hM₂
  let B' := Matrix.fromBlocks B₁' 0 0 B₂'
  have hB' : B'.TU
  · apply Matrix.fromBlocks_TU
    · rwa [Matrix.TU_glue_iff] at hB₁
    · rwa [Matrix.TU_glue_iff] at hB₂
  use (B' · ∘ eY) ∘ eX
  constructor
  · rwa [Matrix.TU_glue_iff, Matrix.mapEquiv_TU]
  · intro i j
    cases hi : eX i <;> cases hj : eY j <;> simp [hi, hj] <;> aesop

/-- Any 2-sum of regular matroids is a regular matroid. -/
theorem BinaryMatroid.Is2sum.isRegular {M : BinaryMatroid X Y} {M₁ : BinaryMatroid X₁ Y₁} {M₂ : BinaryMatroid X₂ Y₂}
    (hM : M.Is2sum M₁ M₂) (hM₁ : M₁.IsRegular) (hM₂ : M₂.IsRegular) :
    M.IsRegular := by
  obtain ⟨eX, eY, hMXY⟩ := hM
  obtain ⟨B₁', hB₁, hBB₁⟩ := hM₁
  obtain ⟨B₂', hB₂, hBB₂⟩ := hM₂
  sorry

/-- Any 3-sum of regular matroids is a regular matroid. -/
theorem BinaryMatroid.Is3sum.isRegular {M : BinaryMatroid X Y} {M₁ : BinaryMatroid X₁ Y₁} {M₂ : BinaryMatroid X₂ Y₂}
    (hM : M.Is3sum M₁ M₂) (hM₁ : M₁.IsRegular) (hM₂ : M₂.IsRegular) :
    M.IsRegular := by
  obtain ⟨eX, eY, hMXY⟩ := hM
  obtain ⟨B₁', hB₁, hBB₁⟩ := hM₁
  obtain ⟨B₂', hB₂, hBB₂⟩ := hM₂
  sorry
