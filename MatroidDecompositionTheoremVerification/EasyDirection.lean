import MatroidDecompositionTheoremVerification.ForMathlib.MatrixTU

open scoped Matrix

/-- The finite field on two elements. -/
abbrev Z2 : Type := Fin 2

variable {α : Type} [DecidableEq α] {X Y : Set α} [∀ x, Decidable (x ∈ X)] [∀ y, Decidable (y ∈ Y)]

/-- Given matrix `B`, is the set of columns `S` in the (standard) representation [`1` | `B`] `Z2`-independent? -/
def Matrix.IndepCols (B : Matrix X Y Z2) (S : Set α) : Prop :=
  ∃ hs : S ⊆ X ∪ Y,
    LinearIndependent Z2
      ((Matrix.fromColumns 1 B).submatrix id
        (fun s : S =>
          if hsX : s.val ∈ X then Sum.inl ⟨s, hsX⟩ else
          if hsY : s.val ∈ Y then Sum.inr ⟨s, hsY⟩ else
          ((hs s.property).elim hsX hsY).elim :
        S → X ⊕ Y)
      ).transpose
/-
/-- The empty set of columns in linearly independent. -/
theorem Matrix.IndepCols_empty (B : Matrix X Y Z2) : B.IndepCols ∅ := by
  sorry

/-- A subset of a linearly independent set of columns in linearly independent. -/
theorem Matrix.IndepCols_subset (B : Matrix X Y Z2) (I J : Set α) (hBJ : B.IndepCols J) (hIJ : I ⊆ J) :
    B.IndepCols I := by
  sorry

/-- A nonmaximal linearly independent set of columns can be augmented with another linearly independent column. -/
theorem Matrix.IndepCols_aug (B : Matrix X Y Z2) (I J : Set α)
    (hBI : B.IndepCols I) (nonmax : ¬Maximal B.IndepCols I) (hBJ : Maximal B.IndepCols J) :
    ∃ x ∈ J \ I, B.IndepCols (insert x I) := by
  sorry

/-- Any set of columns has the maximal subset property. -/
theorem Matrix.IndepCols_maximal (B : Matrix X Y Z2) (S : Set α) :
    Matroid.ExistsMaximalSubsetProperty B.IndepCols S := by
  sorry

/-- Binary matroid generated by its standard representation matrix. -/
def Matrix.toIndepMatroid (B : Matrix X Y Z2) : IndepMatroid α where
  E := X ∪ Y
  Indep := B.IndepCols
  indep_empty := B.IndepCols_empty
  indep_subset := B.IndepCols_subset
  indep_aug := B.IndepCols_aug
  indep_maximal S _ := B.IndepCols_maximal S
  subset_ground _ := Exists.fst

/-- Binary matroid on the ground set `(X ⊕ Y)`. -/
structure BinaryMatroid (X Y : Set α) [∀ x, Decidable (x ∈ X)] [∀ y, Decidable (y ∈ Y)]
  extends IndepMatroid α where
    hXY : Disjoint X Y
    B : Matrix X Y Z2
    hB : B.toIndepMatroid = toIndepMatroid
-/
/-- Binary matroid on the ground set `(X ⊕ Y)`. -/
structure BinaryMatroid (X Y : Set α) [∀ x, Decidable (x ∈ X)] [∀ y, Decidable (y ∈ Y)]
  extends Matroid α where
    hXY : Disjoint X Y
    B : Matrix X Y Z2
    hB : B.IndepCols = Indep

/-- Regular matroid on the ground set `(X ⊕ Y)`. -/
def BinaryMatroid.IsRegular (M : BinaryMatroid X Y) : Prop :=
  ∃ B' : Matrix X Y ℚ, -- signed version of `B`
    (Matrix.fromColumns (1 : Matrix X X ℚ) B').TU ∧ -- the matrix is totally unimodular
    ∀ i : X, ∀ j : Y, if M.B i j = 0 then B' i j = 0 else B' i j = 1 ∨ B' i j = -1 -- `B'` matches `B`

variable
  {X₁ Y₁ : Set α} [∀ x, Decidable (x ∈ X₁)] [∀ y, Decidable (y ∈ Y₁)]
  {X₂ Y₂ : Set α} [∀ x, Decidable (x ∈ X₂)] [∀ y, Decidable (y ∈ Y₂)]

/-- Matrix-level 1-sum for matroids defined by their standard representation matrices. -/
abbrev Matrix.oneSumComposition {β : Type} [Zero β] (A₁ : Matrix X₁ Y₁ β) (A₂ : Matrix X₂ Y₂ β) :
    Matrix (X₁ ⊕ X₂) (Y₁ ⊕ Y₂) β :=
  Matrix.fromBlocks A₁ 0 0 A₂

/-- Matrix-level 2-sum for matroids defined by their standard representation matrices; does not check legitimacy. -/
abbrev Matrix.twoSumComposition (A₁ : Matrix X₁ Y₁ Z2) (x : Y₁ → Z2) (A₂ : Matrix X₂ Y₂ Z2) (y : X₂ → Z2) :
    Matrix (X₁ ⊕ X₂) (Y₁ ⊕ Y₂) Z2 :=
  Matrix.fromBlocks A₁ 0 (fun i j => y i * x j) A₂

/-- Matrix-level 3-sum for matroids defined by their standard representation matrices; does not check legitimacy. -/
noncomputable abbrev Matrix.threeSumComposition (A₁ : Matrix X₁ (Y₁ ⊕ Fin 2) Z2) (A₂ : Matrix (Fin 2 ⊕ X₂) Y₂ Z2)
    (z₁ : Y₁ → Z2) (z₂ : X₂ → Z2)
    (D : Matrix (Fin 2) (Fin 2) Z2) (D₁ : Matrix (Fin 2) Y₁ Z2) (D₂ : Matrix X₂ (Fin 2) Z2) :
    Matrix ((X₁ ⊕ Unit) ⊕ (Fin 2 ⊕ X₂)) ((Y₁ ⊕ Fin 2) ⊕ (Unit ⊕ Y₂)) Z2 :=
  let D₁₂ : Matrix X₂ Y₁ Z2 := D₂ * D⁻¹ * D₁
  Matrix.fromBlocks
    (Matrix.fromRows A₁ (Matrix.row Unit (Sum.elim z₁ ![1, 1]))) 0
    (Matrix.fromBlocks D₁ D D₁₂ D₂) (Matrix.fromColumns (Matrix.col Unit (Sum.elim ![1, 1] z₂)) A₂)

/-- Matroid-level (independent sets) 1-sum for matroids defined by their standard representation matrices. -/
def BinaryMatroid.oneSum (M₁ : BinaryMatroid X₁ Y₁) (M₂ : BinaryMatroid X₂ Y₂) (hX : Disjoint X₁ X₂) (hY : Disjoint Y₁ Y₂) :
    BinaryMatroid (X₁ ∪ X₂) (Y₁ ∪ Y₂) :=
  ⟨sorry, sorry, fun i j =>
    Matrix.oneSumComposition M₁.B M₂.B (
      if hi₁ : i.val ∈ X₁ then Sum.inl ⟨i, hi₁⟩ else
      if hi₂ : i.val ∈ X₂ then Sum.inr ⟨i, hi₂⟩ else
      (i.property.elim hi₁ hi₂).elim
    ) (
      if hj₁ : j.val ∈ Y₁ then Sum.inl ⟨j, hj₁⟩ else
      if hj₂ : j.val ∈ Y₂ then Sum.inr ⟨j, hj₂⟩ else
      (j.property.elim hj₁ hj₂).elim
    ), by sorry⟩

/-- Matroid-level 2-sum for matroids defined by their standard representation matrices; now checks legitimacy. -/
def BinaryMatroid.twoSum (M₁ : BinaryMatroid X₁ Y₁) (M₂ : BinaryMatroid X₂ Y₂)
    {a : α} (hY₁ : a ∉ Y₁) (hX₂ : a ∉ X₂) (ha : X₁ ∩ Y₂ = {a}) :
    BinaryMatroid ((X₁ \ {a} : Set α) ∪ X₂) (Y₁ ∪ (Y₂ \ {a} : Set α)) × Prop :=
  let B₁ := M₁.B -- the standard representation matrix of `M₁`
  let B₂ := M₂.B -- the standard representation matrix of `M₂`
  let A₁ : Matrix (X₁ \ {a} : Set α) Y₁ Z2 := fun i j => B₁ ⟨i.val, Set.mem_of_mem_diff i.property⟩ j -- the top submatrix of `B₁`
  let A₂ : Matrix X₂ (Y₂ \ {a} : Set α) Z2 := fun i j => B₂ i ⟨j.val, Set.mem_of_mem_diff j.property⟩ -- the right submatrix of `B₂`
  let x : Y₁ → Z2 := B₁ ⟨a, Set.mem_of_mem_inter_left (by rw [ha]; rfl)⟩ -- the bottom row of the matrix `B₁`
  let y : X₂ → Z2 := (B₂ · ⟨a, Set.mem_of_mem_inter_right (by rw [ha]; rfl)⟩) -- the leftmost column of the matrix `B₂`
  ⟨
    ⟨sorry, sorry, fun i j =>
      Matrix.twoSumComposition A₁ x A₂ y (
        if hi₁ : i.val ∈ X₁ \ {a} then Sum.inl ⟨i, hi₁⟩ else
        if hi₂ : i.val ∈ X₂ then Sum.inr ⟨i, hi₂⟩ else
        (i.property.elim hi₁ hi₂).elim
      ) (
        if hj₁ : j.val ∈ Y₁ then Sum.inl ⟨j, hj₁⟩ else
        if hj₂ : j.val ∈ Y₂ \ {a} then Sum.inr ⟨j, hj₂⟩ else
        (j.property.elim hj₁ hj₂).elim
      ), by sorry⟩,
    x ≠ 0 ∧ y ≠ 0
  ⟩
/-
/-- Matroid-level 3-sum for matroids defined by their standard representation matrices; now checks legitimacy. -/
noncomputable def BinaryMatroid.threeSum
    (M₁ : BinaryMatroid ((X₁ ⊕ Unit) ⊕ Fin 2) ((Y₁ ⊕ Fin 2) ⊕ Unit))
    (M₂ : BinaryMatroid (Unit ⊕ (Fin 2 ⊕ X₂)) (Fin 2 ⊕ (Unit ⊕ Y₂))) :
    BinaryMatroid ((X₁ ⊕ Unit) ⊕ (Fin 2 ⊕ X₂)) ((Y₁ ⊕ Fin 2) ⊕ (Unit ⊕ Y₂)) × Prop :=
  let B₁ := M₁.B -- the standard representation matrix of `M₁`
  let B₂ := M₂.B -- the standard representation matrix of `M₂`
  let A₁ : Matrix X₁ (Y₁ ⊕ Fin 2) Z2 := ((B₁ ∘ .inl ∘ .inl) · ∘ .inl) -- the top left submatrix
  let A₂ : Matrix (Fin 2 ⊕ X₂) Y₂ Z2 := ((B₂ ∘ .inr) · ∘ .inr ∘ .inr) -- the bottom right submatrix
  let z₁ : Y₁ → Z2 := fun j => B₁ (.inl (.inr ())) (.inl (.inl j)) -- the middle left "row vector"
  let z₂ : X₂ → Z2 := fun i => B₂ (.inr (.inr i)) (.inr (.inl ())) -- the bottom middle "column vector"
  let D_₁ : Matrix (Fin 2) (Fin 2) Z2 := fun i j => B₁ (.inr i) (.inl (.inr j)) -- the bottom middle 2x2 submatrix
  let D_₂ : Matrix (Fin 2) (Fin 2) Z2 := fun i j => B₂ (.inr (.inl i)) (.inl j) -- the middle left 2x2 submatrix
  let D₁ : Matrix (Fin 2) Y₁ Z2 := fun i j => B₁ (.inr i) (.inl (.inl j)) -- the bottom left submatrix
  let D₂ : Matrix X₂ (Fin 2) Z2 := fun i j => B₂ (.inr (.inr i)) (.inl j) -- the bottom left submatrix
  ⟨
    ⟨_, Matrix.threeSumComposition A₁ A₂ z₁ z₂ D_₁ D₁ D₂, rfl⟩,
    IsUnit D_₁ ∧ D_₁ = D_₂ -- the matrix `D_₁ = D_₂` (called D-bar in the book) is invertible
  ⟩
-/
/-- Matroid `M` is a result of 1-summing `M₁` and `M₂` (should be equivalent to direct sums). -/
def BinaryMatroid.Is1sum (M : BinaryMatroid (X₁ ∪ X₂) (Y₁ ∪ Y₂)) (M₁ : BinaryMatroid X₁ Y₁) (M₂ : BinaryMatroid X₂ Y₂) : Prop :=
  ∃ disjointX : Disjoint X₁ X₂, ∃ disjointY : Disjoint Y₁ Y₂, M = BinaryMatroid.oneSum M₁ M₂ disjointX disjointY
/-
/-- Matroid `M` is a result of 1-summing `M₁` and `M₂` (should be equivalent to direct sums). -/
def BinaryMatroid.Is1sum (M : BinaryMatroid (X₁ ∪ X₂) (Y₁ ∪ Y₂)) (M₁ : BinaryMatroid X₁ Y₁) (M₂ : BinaryMatroid X₂ Y₂) : Prop :=
  (Disjoint X₁ X₂ ∧ Disjoint Y₁ Y₂) ∧
    ∀ i j, M.B i j =
      Matrix.oneSumComposition M₁.B M₂.B (
        if hi₁ : i.val ∈ X₁ then Sum.inl ⟨i, hi₁⟩ else
        if hi₂ : i.val ∈ X₂ then Sum.inr ⟨i, hi₂⟩ else
        (i.property.elim hi₁ hi₂).elim
      ) (
        if hj₁ : j.val ∈ Y₁ then Sum.inl ⟨j, hj₁⟩ else
        if hj₂ : j.val ∈ Y₂ then Sum.inr ⟨j, hj₂⟩ else
        (j.property.elim hj₁ hj₂).elim
      )
-/
/-- Matroid `M` is a result of 2-summing `M₁` and `M₂` in some way. -/
def BinaryMatroid.Is2sum {a : α} (M : BinaryMatroid ((X₁ \ {a} : Set α) ∪ X₂) (Y₁ ∪ (Y₂ \ {a} : Set α)))
  (M₁ : BinaryMatroid X₁ Y₁) (M₂ : BinaryMatroid X₂ Y₂) : Prop :=
  (Disjoint X₁ X₂ ∧ Disjoint Y₁ Y₂) ∧
    ∃ hY₁ : a ∉ Y₁, ∃ hX₂ : a ∉ X₂, ∃ ha : X₁ ∩ Y₂ = {a},
      let M₀ := BinaryMatroid.twoSum M₁ M₂ hY₁ hX₂ ha
      M = M₀.fst ∧ M₀.snd
/-
/-- Matroid `M` is a result of 3-summing `M₁` and `M₂` in some way. -/
def BinaryMatroid.Is3sum (M : BinaryMatroid X Y) (M₁ : BinaryMatroid X₁ Y₁) (M₂ : BinaryMatroid X₂ Y₂) : Prop :=
  let B₁ := M₁.B -- the standard representation matrix of `M₁`
  let B₂ := M₂.B -- the standard representation matrix of `M₂`
  ∃ X₁' Y₁' : Type, ∃ _ : DecidableEq X₁', ∃ _ : DecidableEq Y₁', -- indexing types for the shared parts
  ∃ X₂' Y₂' : Type, ∃ _ : DecidableEq X₂', ∃ _ : DecidableEq Y₂', -- indexing types for the shared parts
    ∃ hX₁ : X₁ = ((X₁' ⊕ Unit) ⊕ Fin 2), ∃ hY₁ : Y₁ = ((Y₁' ⊕ Fin 2) ⊕ Unit),
    ∃ hX₂ : X₂ = (Unit ⊕ (Fin 2 ⊕ X₂')), ∃ hY₂ : Y₂ = (Fin 2 ⊕ (Unit ⊕ Y₂')),
      ∃ eX : X ≃ ((X₁' ⊕ Unit) ⊕ (Fin 2 ⊕ X₂')), ∃ eY : Y ≃ ((Y₁' ⊕ Fin 2) ⊕ (Unit ⊕ Y₂')),
        let M₀ := BinaryMatroid.threeSum
            ⟨M₁.cast (by subst hX₁ hY₁; rfl), hX₁ ▸ hY₁ ▸ B₁, (by subst hX₁ hY₁; convert M₁.hB)⟩
            ⟨M₂.cast (by subst hX₂ hY₂; rfl), hX₂ ▸ hY₂ ▸ B₂, (by subst hX₂ hY₂; convert M₂.hB)⟩
        M = M₀.fst.mapEquiv eX eY ∧ M₀.snd
-/
/-- Any 1-sum of regular matroids is a regular matroid. -/
theorem BinaryMatroid.Is1sum.isRegular {M : BinaryMatroid (X₁ ∪ X₂) (Y₁ ∪ Y₂)}
    {M₁ : BinaryMatroid X₁ Y₁} {M₂ : BinaryMatroid X₂ Y₂}
    (hM : M.Is1sum M₁ M₂) (hM₁ : M₁.IsRegular) (hM₂ : M₂.IsRegular) :
    M.IsRegular := by
  obtain ⟨eX, eY, hMXY⟩ := hM
  obtain ⟨B₁', hB₁, hBB₁⟩ := hM₁
  obtain ⟨B₂', hB₂, hBB₂⟩ := hM₂
  let B' := Matrix.fromBlocks B₁' 0 0 B₂'
  have hB' : B'.TU
  · apply Matrix.fromBlocks_TU
    · rwa [Matrix.TU_glue_iff] at hB₁
    · rwa [Matrix.TU_glue_iff] at hB₂
  sorry

/-- Any 2-sum of regular matroids is a regular matroid. -/
theorem BinaryMatroid.Is2sum.isRegular {a : α} {M : BinaryMatroid ((X₁ \ {a} : Set α) ∪ X₂) (Y₁ ∪ (Y₂ \ {a} : Set α))}
    {M₁ : BinaryMatroid X₁ Y₁} {M₂ : BinaryMatroid X₂ Y₂}
    (hM : M.Is2sum M₁ M₂) (hM₁ : M₁.IsRegular) (hM₂ : M₂.IsRegular) :
    M.IsRegular := by
  obtain ⟨eX, eY, hMXY⟩ := hM
  obtain ⟨B₁', hB₁, hBB₁⟩ := hM₁
  obtain ⟨B₂', hB₂, hBB₂⟩ := hM₂
  sorry
/-
/-- Any 3-sum of regular matroids is a regular matroid. -/
theorem BinaryMatroid.Is3sum.isRegular {M : BinaryMatroid X Y} {M₁ : BinaryMatroid X₁ Y₁} {M₂ : BinaryMatroid X₂ Y₂}
    (hM : M.Is3sum M₁ M₂) (hM₁ : M₁.IsRegular) (hM₂ : M₂.IsRegular) :
    M.IsRegular := by
  obtain ⟨eX, eY, hMXY⟩ := hM
  obtain ⟨B₁', hB₁, hBB₁⟩ := hM₁
  obtain ⟨B₂', hB₂, hBB₂⟩ := hM₂
  sorry
-/
