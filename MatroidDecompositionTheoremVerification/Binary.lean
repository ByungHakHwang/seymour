import Mathlib


abbrev Z2 : Type := Fin 2

variable {X Y : Type} [DecidableEq X] [DecidableEq Y]

/-- Binary prematroid generated by its standard representation matrix. -/
def Matrix.IndepCols (A : Matrix X Y Z2) (S : Set (X ⊕ Y)) : Prop :=
  LinearIndependent Z2 ((Matrix.fromColumns 1 A).submatrix id ((↑) : S → (X ⊕ Y))).transpose

theorem Matrix.IndepCols_empty (A : Matrix X Y Z2) : A.IndepCols ∅ := by
  sorry

theorem Matrix.IndepCols_subset (A : Matrix X Y Z2) (I J : Set (X ⊕ Y)) (hAJ : A.IndepCols J) (hIJ : I ⊆ J) :
    A.IndepCols I := by
  sorry

theorem Matrix.IndepCols_aug (A : Matrix X Y Z2) (I B : Set (X ⊕ Y))
    (hAI : A.IndepCols I) (nonmax : ¬Maximal A.IndepCols I) (hAB : Maximal A.IndepCols B) :
    ∃ x ∈ B \ I, A.IndepCols (insert x I) := by
  sorry

theorem Matrix.IndepCols_maximal (A : Matrix X Y Z2) (S : Set (X ⊕ Y)) (hS : S ⊆ Set.univ) :
    Matroid.ExistsMaximalSubsetProperty A.IndepCols S := by
  sorry

/-- Binary matroid generated by its standard representation matrix. -/
def Matrix.toIndepMatroid (A : Matrix X Y Z2) : IndepMatroid (X ⊕ Y) where
  E := Set.univ
  Indep := A.IndepCols
  indep_empty := A.IndepCols_empty
  indep_subset := A.IndepCols_subset
  indep_aug := A.IndepCols_aug
  indep_maximal := A.IndepCols_maximal
  subset_ground := fun _ _ _ _ => trivial

structure IndepMatroid.IsBinary (M : IndepMatroid (X ⊕ Y)) : Type where
  B : Matrix X Y Z2
  hB : B.toIndepMatroid = M

def Matrix.TU (A : Matrix X Y ℚ) : Prop :=
  ∀ k : ℕ, ∀ f : Fin k → X, ∀ g : Fin k → Y,
    Function.Injective f → Function.Injective g →
      (A.submatrix f g).det = 0 ∨
      (A.submatrix f g).det = 1 ∨
      (A.submatrix f g).det = -1

structure IndepMatroid.IsRegular (M : IndepMatroid (X ⊕ Y)) : Type where
  A : Matrix X Y ℚ
  B : Matrix X Y Z2
  hA : (Matrix.fromColumns (1 : Matrix X X ℚ) A).TU
  hBM : B.toIndepMatroid = M
  hBA : ∀ i : X, ∀ j : Y, if B i j = 0 then A i j = 0 else A i j = 1 ∨ A i j = -1

def Matroid.IsRegular.isBinary {M : IndepMatroid (X ⊕ Y)} (hM : M.IsRegular) : M.IsBinary :=
  ⟨hM.B, hM.hBM⟩

def Matrix.TwoSumComposition {X₁ X₂ Y₁ Y₂ : Type}
    [DecidableEq X₁] [DecidableEq Y₁]
    [DecidableEq X₂] [DecidableEq Y₂]
    (A₁ : Matrix X₁ Y₁ Z2) (x : Y₁ → Z2)
    (A₂ : Matrix X₂ Y₂ Z2) (y : X₂ → Z2) :
    Matrix (X₁ ⊕ X₂) (Y₁ ⊕ Y₂) Z2 :=
  Matrix.fromBlocks A₁ 0 (fun i j => y i * x j) A₂

def IndepMatroid.TwoSum {X₁ X₂ Y₁ Y₂ : Type}
    [DecidableEq X₁] [DecidableEq Y₁]
    [DecidableEq X₂] [DecidableEq Y₂]
    {M₁ : IndepMatroid ((X₁ ⊕ Unit) ⊕ Y₁)}
    {M₂ : IndepMatroid (X₂ ⊕ (Unit ⊕ Y₂))}
    (hM₁ : M₁.IsBinary) (hM₂ : M₂.IsBinary) :
    IndepMatroid ((X₁ ⊕ X₂) ⊕ (Y₁ ⊕ Y₂)) :=
  let ⟨B₁, _⟩ := hM₁
  let ⟨B₂, _⟩ := hM₂
  let A₁ : Matrix X₁ Y₁ Z2 := B₁ ∘ Sum.inl
  let A₂ : Matrix X₂ Y₂ Z2 := (B₂ · ∘ Sum.inr)
  let x : Y₁ → Z2 := (B₁ ∘ Sum.inr) ()       -- makes sense only if `x ≠ 0`
  let y : X₂ → Z2 := ((B₂ · ∘ Sum.inl) · ()) -- makes sense only if `y ≠ 0`
  (Matrix.TwoSumComposition A₁ x A₂ y).toIndepMatroid

def IndepMatroid.cast (M : IndepMatroid X) (hXY : X = Y) : IndepMatroid Y where
  E := hXY ▸ M.E
  Indep := hXY ▸ M.Indep
  indep_empty := by subst hXY; exact M.indep_empty
  indep_subset := by subst hXY; exact M.indep_subset
  indep_aug := by subst hXY; exact M.indep_aug
  indep_maximal := by subst hXY; exact M.indep_maximal
  subset_ground := by subst hXY; exact M.subset_ground

def IndepMatroid.mapEquiv (M : IndepMatroid X) (eXY : X ≃ Y) : IndepMatroid Y where
  E := eXY '' M.E
  Indep I := ∃ I₀, M.Indep I₀ ∧ I = eXY '' I₀
  indep_empty := ⟨∅, M.indep_empty, (Set.image_empty eXY).symm⟩
  indep_subset I J hI hJ := by
    obtain ⟨I', hIJ⟩ := hI
    refine ⟨eXY.symm '' I, ?_, (Equiv.eq_image_iff_symm_image_eq eXY _ I).mpr rfl⟩
    have := M.indep_subset (I := eXY.symm '' I) (J := eXY.symm '' J)
    simp_all only [Equiv.symm_image_image, Equiv.symm_image_subset, true_implies]
  indep_aug := by sorry
  indep_maximal I := by sorry
  subset_ground I hI := by have := M.subset_ground (eXY.symm '' I); aesop

def IndepMatroid.IsTwoSum {X₁ X₂ Y₁ Y₂ : Type}
    [DecidableEq X₁] [DecidableEq Y₁]
    [DecidableEq X₂] [DecidableEq Y₂]
    {M₁ : IndepMatroid (X₁ ⊕ Y₁)}
    {M₂ : IndepMatroid (X₂ ⊕ Y₂)}
    (hM₁ : M₁.IsBinary) (hM₂ : M₂.IsBinary)
    (M : IndepMatroid (X ⊕ Y)) :
    Prop :=
  let ⟨B₁, hB₁⟩ := hM₁
  let ⟨B₂, hB₂⟩ := hM₂
  ∃ X' Y' : Type, ∃ _ : DecidableEq X', ∃ _ : DecidableEq Y',
    ∃ hX₁ : X₁ = (X' ⊕ Unit), ∃ hY₂ : Y₂ = (Unit ⊕ Y'), ∃ eX : (X' ⊕ X₂) ≃ X, ∃ eY : (Y₁ ⊕ Y') ≃ Y,
      M = IndepMatroid.mapEquiv (
        @IndepMatroid.TwoSum _ _ _ _ _ _ _ _
          (M₁.cast (congr_arg (· ⊕ Y₁) hX₁))
          (M₂.cast (congr_arg (X₂ ⊕ ·) hY₂))
          ⟨hX₁ ▸ B₁, by subst hX₁; convert hB₁⟩
          ⟨hY₂ ▸ B₂, by subst hY₂; convert hB₂⟩
      ) (Equiv.sumCongr eX eY) ∧
      (hX₁ ▸ B₁) (Sum.inr ()) ≠ (0 : Y₁ → Z2) ∧ (fun i : X₂ => (hY₂ ▸ B₂ i) (Sum.inl ())) ≠ (0 : X₂ → Z2)
