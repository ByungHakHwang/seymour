import Mathlib


abbrev Z2 : Type := Fin 2

variable {X Y : Type} [DecidableEq X] [DecidableEq Y]

/-- Binary prematroid generated by its standard representation matrix. -/
def Matrix.IndepCols (A : Matrix X Y Z2) (S : Set (X ⊕ Y)) : Prop :=
  LinearIndependent Z2 ((Matrix.fromColumns 1 A).submatrix id ((↑) : S → (X ⊕ Y))).transpose

theorem Matrix.IndepCols_empty (A : Matrix X Y Z2) : A.IndepCols ∅ := by
  sorry

theorem Matrix.IndepCols_subset (A : Matrix X Y Z2) (I J : Set (X ⊕ Y)) (hAJ : A.IndepCols J) (hIJ : I ⊆ J) :
    A.IndepCols I := by
  sorry

theorem Matrix.IndepCols_aug (A : Matrix X Y Z2) (I B : Set (X ⊕ Y))
    (AI : A.IndepCols I) (hAI : ¬Maximal A.IndepCols I) (hAB : Maximal A.IndepCols B) :
    ∃ x ∈ B \ I, A.IndepCols (insert x I) := by
  sorry

theorem Matrix.IndepCols_maximal (A : Matrix X Y Z2) (S : Set (X ⊕ Y)) (hS : S ⊆ Set.univ) :
    Matroid.ExistsMaximalSubsetProperty A.IndepCols S := by
  sorry

/-- Binary matroid generated by its standard representation matrix. -/
def Matrix.toIndepMatroid (A : Matrix X Y Z2) : IndepMatroid (X ⊕ Y) where
  E := Set.univ
  Indep := A.IndepCols
  indep_empty := A.IndepCols_empty
  indep_subset := A.IndepCols_subset
  indep_aug := A.IndepCols_aug
  indep_maximal := A.IndepCols_maximal
  subset_ground := fun _ _ _ _ => trivial

structure IndepMatroid.IsBinary (M : IndepMatroid (X ⊕ Y)) : Type where
  B : Matrix X Y Z2
  hB : B.toIndepMatroid = M

def Matrix.TU (A : Matrix X Y ℚ) : Prop :=
  ∀ k : ℕ, ∀ f : Fin k → X, ∀ g : Fin k → Y,
    Function.Injective f → Function.Injective g →
      (A.submatrix f g).det = 0 ∨
      (A.submatrix f g).det = 1 ∨
      (A.submatrix f g).det = -1

structure IndepMatroid.IsRegular (M : IndepMatroid (X ⊕ Y)) : Type where
  A : Matrix X Y ℚ
  B : Matrix X Y Z2
  hA : (Matrix.fromColumns (1 : Matrix X X ℚ) A).TU
  hBM : B.toIndepMatroid = M
  hBA : ∀ i : X, ∀ j : Y, if B i j = 0 then A i j = 0 else A i j = 1 ∨ A i j = -1

def Matroid.IsRegular.isBinary {M : IndepMatroid (X ⊕ Y)} (hM : M.IsRegular) : M.IsBinary :=
  ⟨hM.B, hM.hBM⟩

def Matrix.TwoSumComposition {X₁ X₂ Y₁ Y₂ : Type}
    [DecidableEq X₁] [DecidableEq Y₁]
    [DecidableEq X₂] [DecidableEq Y₂]
    (A₁ : Matrix X₁ Y₁ Z2) (x : Y₁ → Z2)
    (A₂ : Matrix X₂ Y₂ Z2) (y : X₂ → Z2) :
    Matrix (X₁ ⊕ X₂) (Y₁ ⊕ Y₂) Z2 :=
  Matrix.fromBlocks A₁ 0 (fun i j => y i * x j) A₂

def Matroid.TwoSum {X₁ X₂ Y₁ Y₂ : Type}
    [DecidableEq X₁] [DecidableEq Y₁]
    [DecidableEq X₂] [DecidableEq Y₂]
    {M₁ : IndepMatroid ((X₁ ⊕ Unit) ⊕ Y₁)} -- TODO the Unit row ≠ 0
    {M₂ : IndepMatroid (X₂ ⊕ (Unit ⊕ Y₂))} -- TODO the Unit col ≠ 0
    (hM₁ : M₁.IsBinary) (hM₂ : M₂.IsBinary) :
    IndepMatroid ((X₁ ⊕ X₂) ⊕ (Y₁ ⊕ Y₂)) :=
  let ⟨B₁, _⟩ := hM₁
  let ⟨B₂, _⟩ := hM₂
  let A₁ : Matrix X₁ Y₁ Z2 := B₁ ∘ Sum.inl
  let A₂ : Matrix X₂ Y₂ Z2 := (B₂ · ∘ Sum.inr)
  let x : Y₁ → Z2 := (B₁ ∘ Sum.inr) ()       -- makes sense only if `x ≠ 0`
  let y : X₂ → Z2 := ((B₂ · ∘ Sum.inl) · ()) -- makes sense only if `y ≠ 0`
  (Matrix.TwoSumComposition A₁ x A₂ y).toIndepMatroid
