import Mathlib

variable {X Y : Type} [DecidableEq X] [DecidableEq Y]

/-- Binary prematroid generated by its standard representation matrix. -/
def Matrix.toBinaryIndepCols (A : Matrix X Y (Fin 2)) : Set (Set (X ⊕ Y)) :=
  { S : Set (X ⊕ Y) |
    LinearIndependent (Fin 2) ((Matrix.fromColumns 1 A).submatrix id ((↑) : S → (X ⊕ Y))).transpose }

theorem Matrix.toBinaryIndepCols_empty (A : Matrix X Y (Fin 2)) : A.toBinaryIndepCols ∅ := by
  sorry

theorem Matrix.toBinaryIndepCols_subset (A : Matrix X Y (Fin 2)) ⦃I J : Set (X ⊕ Y)⦄ :
    A.toBinaryIndepCols J → I ⊆ J → A.toBinaryIndepCols I := by
  sorry

theorem Matrix.toBinaryIndepCols_aug (A : Matrix X Y (Fin 2)) ⦃I B : Set (X ⊕ Y)⦄ :
    A.toBinaryIndepCols I → ¬Maximal A.toBinaryIndepCols I →
      Maximal A.toBinaryIndepCols B → ∃ x ∈ B \ I, A.toBinaryIndepCols (insert x I) := by
  sorry

theorem Matrix.toBinaryIndepCols_maximal (A : Matrix X Y (Fin 2)) (X : Set (X ⊕ Y)) :
    X ⊆ Set.univ → Matroid.ExistsMaximalSubsetProperty A.toBinaryIndepCols X := by
  sorry

/-- Binary matroid generated by its standard representation matrix. -/
def Matrix.toMatroid (A : Matrix X Y (Fin 2)) : IndepMatroid (X ⊕ Y) where
  E := Set.univ
  Indep := A.toBinaryIndepCols
  indep_empty := A.toBinaryIndepCols_empty
  indep_subset := A.toBinaryIndepCols_subset
  indep_aug := A.toBinaryIndepCols_aug
  indep_maximal := A.toBinaryIndepCols_maximal
  subset_ground := fun _ _ _ _ => trivial

def Matroid.IsBinary (M : Matroid (X ⊕ Y)) : Prop :=
  ∃ A : Matrix X Y (Fin 2), A.toMatroid.matroid = M

def Matrix.TU (A : Matrix X Y ℚ) : Prop :=
  ∀ (b : ℕ) (f : Fin (b+1) → X) (g : Fin (b+1) → Y),
    Function.Injective f ∧ Function.Injective g →
      Matrix.det (A.submatrix f g) ∈ ({0,-1,1} : Set ℚ)

def Matroid.IsRegular (M : Matroid (X ⊕ Y)) : Prop :=
  ∃ A : Matrix X Y ℚ, (Matrix.fromColumns (1 : Matrix X X ℚ) A).TU ∧
    ∃ B : Matrix X Y (Fin 2), B.toMatroid.matroid = M ∧
      ∀ i : X, ∀ j : Y, if B i j = 0 then A i j = 0 else A i j = 1 ∨ A i j = -1

lemma Matroid.IsRegular.isBinary {M : Matroid (X ⊕ Y)} (hM : M.IsRegular) : M.IsBinary := by
  obtain ⟨-, -, B, _, -⟩ := hM
  use B
/-
def Matroid.TwoSumComposition {X₁ X₂ Y₁ Y₂ : Type}
    [DecidableEq X₁] [DecidableEq Y₁]
    [DecidableEq X₂] [DecidableEq Y₂]
    {M₁ : Matroid (X₁ ⊕ Y₁)} {x : Y₁ → Fin 2} (hx : x ≠ 0)
    {M₂ : Matroid (X₂ ⊕ Y₂)} {y : X₂ → Fin 2} (hy : y ≠ 0)
    (hM₁ : M₁.IsBinary) (hM₂ : M₂.IsBinary) :
    Matroid ((X₁ ⊕ Y₁) ⊕ (X₂ ⊕ Y₂)) :=
  let ⟨B₁, hB₁⟩ := hM₁
  let ⟨B₂, hB₂⟩ := hM₁
-/
def Matrix.TwoSumComposition {X₁ X₂ Y₁ Y₂ : Type}
    [DecidableEq X₁] [DecidableEq Y₁]
    [DecidableEq X₂] [DecidableEq Y₂]
    (A₁ : Matrix X₁ Y₁ (Fin 2)) {x : Y₁ → Fin 2} (hx : x ≠ 0)
    (A₂ : Matrix X₂ Y₂ (Fin 2)) {y : X₂ → Fin 2} (hy : y ≠ 0) :
    Matrix (X₁ ⊕ X₂) (Y₁ ⊕ Y₂) (Fin 2) :=
  Matrix.fromBlocks A₁ 0 (fun i j => y i * x j) A₂

def Matroid.TwoSumComposition {X₁ X₂ Y₁ Y₂ : Type}
    [DecidableEq X₁] [DecidableEq Y₁]
    [DecidableEq X₂] [DecidableEq Y₂]
    {M₁ : Matroid ((X₁ ⊕ Unit) ⊕ Y₁)} -- TODO Unit row ≠ 0
    {M₂ : Matroid (X₂ ⊕ (Unit ⊕ Y₂))} -- TODO Unit col ≠ 0
    (hM₁ : M₁.IsBinary) (hM₂ : M₂.IsBinary) :
    IndepMatroid ((X₁ ⊕ X₂) ⊕ (Y₁ ⊕ Y₂)) :=
  --let ⟨B₁, hB₁⟩ := hM₁
  --let ⟨B₂, hB₂⟩ := hM₂
  let A₁ : Matrix X₁ Y₁ (Fin 2) := sorry
  let A₂ : Matrix X₂ Y₂ (Fin 2) := sorry
  let x : Y₁ → Fin 2 := sorry
  let y : X₂ → Fin 2 := sorry
  have hx : x ≠ 0 := sorry
  have hy : y ≠ 0 := sorry
  -- TODO extract A₁ is the submatrix of B₁ (remove the last row)
  -- TODO extract A₂ is the submatrix of B₂ (remove the first col)
  (Matrix.TwoSumComposition A₁ hx A₂ hy).toMatroid
/-
def Matroid.TwoSumComposition {X₁ X₂ Y₁ Y₂ : Type}
    [DecidableEq X₁] [DecidableEq Y₁]
    [DecidableEq X₂] [DecidableEq Y₂]
    {M₁ : Matroid ((X₁ ⊕ Unit) ⊕ Y₁)}
    {M₂ : Matroid ((X₂ ⊕ Unit) ⊕ Y₂)}
    (hM₁ : M₁.IsBinary) (hM₂ : M₂.IsBinary) :
    Matroid ((X₁ ⊕ Y₁) ⊕ (X₂ ⊕ Y₂)) :=
  sorry
-/
