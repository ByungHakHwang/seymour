import Mathlib.Data.Matroid.IndepAxioms
import Seymour.ForMathlib.MatrixTU
import Seymour.Mathlib.Sets

open scoped Matrix

/-- The finite field on two elements. -/
abbrev Z2 : Type := ZMod 2

infixr:66 " ᕃ " => Insert.insert -- TODO (low priority) use `syntax` and write a custom delaborator

infix:61 " ⫗ " => Disjoint

section construction_from_matrices

variable {α : Type} [DecidableEq α] {X Y : Set α} [∀ x, Decidable (x ∈ X)] [∀ y, Decidable (y ∈ Y)]
-- Do not refactor to `[DecidablePred X.Mem]` and so on!

def convertUnionSum (i : (X ∪ Y).Elem) : X.Elem ⊕ Y.Elem :=
  if hiX : i.val ∈ X then Sum.inl ⟨i, hiX⟩ else
  if hiY : i.val ∈ Y then Sum.inr ⟨i, hiY⟩ else
  ((i.property).elim hiX hiY).elim

def subsetElem (hXY : X ⊆ Y) (x : X.Elem) : Y.Elem :=
  ⟨x.val, hXY x.property⟩

/-- Given matrix `B`, is the set of columns `S` in the (standard) representation [`1` | `B`] `Z2`-independent? -/
def Matrix.IndepCols (B : Matrix X Y Z2) (S : Set α) : Prop :=
  ∃ hs : S ⊆ X ∪ Y,
    LinearIndependent Z2 ((Matrix.fromColumns 1 B).submatrix id (convertUnionSum ∘ subsetElem hs)).transpose

/-- The empty set of columns in linearly independent. -/
theorem Matrix.IndepCols_empty (B : Matrix X Y Z2) : B.IndepCols ∅ := by
  use Set.empty_subset (X ∪ Y)
  exact linearIndependent_empty_type

/-- A subset of a linearly independent set of columns in linearly independent. -/
theorem Matrix.IndepCols_subset (B : Matrix X Y Z2) (I J : Set α) (hBJ : B.IndepCols J) (hIJ : I ⊆ J) :
    B.IndepCols I := by
  obtain ⟨hJ, hB⟩ := hBJ
  use hIJ.trans hJ
  let I' := { i : J.Elem // i.val ∈ I }
  let e : I' ≃ I := (Equiv.subtypeSubtypeEquivSubtype (by convert hIJ))
  sorry

/-- A nonmaximal linearly independent set of columns can be augmented with another linearly independent column. -/
theorem Matrix.IndepCols_aug (B : Matrix X Y Z2) (I J : Set α)
    (hBI : B.IndepCols I) (nonmax : ¬Maximal B.IndepCols I) (hBJ : Maximal B.IndepCols J) :
    ∃ x ∈ J \ I, B.IndepCols (x ᕃ I) := by
  sorry

/-- Any set of columns has the maximal subset property. -/
theorem Matrix.IndepCols_maximal (B : Matrix X Y Z2) (S : Set α) :
    Matroid.ExistsMaximalSubsetProperty B.IndepCols S := by
  sorry

/-- Binary matroid generated by its standard representation matrix, expressed as `IndepMatroid`. -/
def Matrix.toIndepMatroid (B : Matrix X Y Z2) : IndepMatroid α where
  E := X ∪ Y
  Indep := B.IndepCols
  indep_empty := B.IndepCols_empty
  indep_subset := B.IndepCols_subset
  indep_aug := B.IndepCols_aug
  indep_maximal S _ := B.IndepCols_maximal S
  subset_ground _ := Exists.fst

/-- Binary matroid generated by its standard representation matrix, expressed as `Matroid`. -/
def Matrix.toMatroid (B : Matrix X Y Z2) : Matroid α := B.toIndepMatroid.matroid

end construction_from_matrices

/-- Data describing a binary matroid on the ground set `X ∪ Y` where `X` and `Y` are bundled. -/
structure BinaryMatroid (α : Type) [DecidableEq α] where
  X : Set α
  Y : Set α
  decmemX : ∀ x, Decidable (x ∈ X)
  decmemY : ∀ y, Decidable (y ∈ Y)
  hXY : X ⫗ Y
  B : Matrix X Y Z2

attribute [instance] BinaryMatroid.decmemX
attribute [instance] BinaryMatroid.decmemY

variable {α : Type} [DecidableEq α]

def BinaryMatroid.toMatroid (M : BinaryMatroid α) :=
  M.B.toMatroid

@[simp]
lemma BinaryMatroid.indep_eq (M : BinaryMatroid α) : M.toMatroid.Indep = M.B.IndepCols :=
  rfl

instance : Coe (BinaryMatroid α) (Matroid α) where
  coe := BinaryMatroid.toMatroid

/-- The binary matroid on the ground set `X ∪ Y` is regular. -/
def BinaryMatroid.IsRegular (M : BinaryMatroid α) : Prop :=
  ∃ B' : Matrix M.X M.Y ℚ, -- signed version of `B`
    (Matrix.fromColumns (1 : Matrix M.X M.X ℚ) B').TU ∧ -- the matrix is totally unimodular
    ∀ i : M.X, ∀ j : M.Y, if M.B i j = 0 then B' i j = 0 else B' i j = 1 ∨ B' i j = -1 -- `B'` matches `B`

section matrix_level

variable {X₁ Y₁ : Set α} {X₂ Y₂ : Set α} {β : Type} [Field β]

/-- Matrix-level 1-sum for matroids defined by their standard representation matrices. -/
abbrev Matrix.oneSumComposition (A₁ : Matrix X₁ Y₁ β) (A₂ : Matrix X₂ Y₂ β) :
    Matrix (X₁ ⊕ X₂) (Y₁ ⊕ Y₂) β :=
  Matrix.fromBlocks A₁ 0 0 A₂

/-- Matrix-level 2-sum for matroids defined by their standard representation matrices; does not check legitimacy. -/
abbrev Matrix.twoSumComposition (A₁ : Matrix X₁ Y₁ β) (x : Y₁ → β) (A₂ : Matrix X₂ Y₂ β) (y : X₂ → β) :
    Matrix (X₁ ⊕ X₂) (Y₁ ⊕ Y₂) β :=
  Matrix.fromBlocks A₁ 0 (fun i j => y i * x j) A₂

/-- Matrix-level 3-sum for matroids defined by their standard representation matrices; does not check legitimacy. -/
noncomputable abbrev Matrix.threeSumComposition (A₁ : Matrix X₁ (Y₁ ⊕ Fin 2) β) (A₂ : Matrix (Fin 2 ⊕ X₂) Y₂ β)
    (z₁ : Y₁ → β) (z₂ : X₂ → β) (D : Matrix (Fin 2) (Fin 2) β) (D₁ : Matrix (Fin 2) Y₁ β) (D₂ : Matrix X₂ (Fin 2) β) :
    Matrix ((X₁ ⊕ Unit) ⊕ (Fin 2 ⊕ X₂)) ((Y₁ ⊕ Fin 2) ⊕ (Unit ⊕ Y₂)) β :=
  let D₁₂ : Matrix X₂ Y₁ β := D₂ * D⁻¹ * D₁
  Matrix.fromBlocks
    (Matrix.fromRows A₁ (Matrix.row Unit (Sum.elim z₁ ![1, 1]))) 0
    (Matrix.fromBlocks D₁ D D₁₂ D₂) (Matrix.fromColumns (Matrix.col Unit (Sum.elim ![1, 1] z₂)) A₂)

end matrix_level

def Matrix.toMatrixUnionUnion {T T₁ T₂ S S₁ S₂ : Set α}
    [∀ a, Decidable (a ∈ T₁)] [∀ a, Decidable (a ∈ T₂)] [∀ a, Decidable (a ∈ S₁)] [∀ a, Decidable (a ∈ S₂)]
    {β : Type} (C : Matrix (T₁.Elem ⊕ T₂.Elem) (S₁.Elem ⊕ S₂.Elem) β) (hT : T = T₁ ∪ T₂) (hS : S = S₁ ∪ S₂) :
    Matrix T S β :=
  Matrix.of (fun i j => C (convertUnionSum (hT ▸ i)) (convertUnionSum (hS ▸ j)))

/-- Matroid-level (independent sets) 1-sum for matroids defined by their standard representation matrices.
It checks that everything is disjoint. -/
def BinaryMatroid.oneSum {M₁ M₂ : BinaryMatroid α} (hXY : M₁.X ⫗ M₂.Y) (hYX : M₁.Y ⫗ M₂.X) :
    BinaryMatroid α × Prop :=
  let B : Matrix (M₁.X ∪ M₂.X).Elem (M₁.Y ∪ M₂.Y).Elem Z2 := (Matrix.oneSumComposition M₁.B M₂.B).toMatrixUnionUnion rfl rfl
  ⟨
    ⟨
      M₁.X ∪ M₂.X,
      M₁.Y ∪ M₂.Y,
      (Set.decidableUnion _ _ ·),
      (Set.decidableUnion _ _ ·),
      by simp only [Set.disjoint_union_left, Set.disjoint_union_right]; exact ⟨⟨M₁.hXY, hYX.symm⟩, ⟨hXY, M₂.hXY⟩⟩,
      B
    ⟩,
    M₁.X ⫗ M₂.X ∧ M₁.Y ⫗ M₂.Y
  ⟩

/-- Matroid-level 2-sum for matroids defined by their standard representation matrices; now checks legitimacy.
The ground sets of `M₁` and `M₂` are disjoint except for element a that lies in `M₁.X` and `M₂.Y`;
moreover, the special row of `M₁` and the special column of `M₂` are nonzero. -/
def BinaryMatroid.twoSum {M₁ M₂ : BinaryMatroid α} {a : α} (ha : M₁.X ∩ M₂.Y = {a}) (hXY : M₂.X ⫗ M₁.Y) :
    BinaryMatroid α × Prop :=
  let A₁ : Matrix (M₁.X \ {a}).Elem M₁.Y.Elem Z2 := M₁.B ∘ subsetElem Set.diff_subset -- the top submatrix of `B₁`
  let A₂ : Matrix M₂.X.Elem (M₂.Y \ {a}).Elem Z2 := (M₂.B · ∘ subsetElem Set.diff_subset) -- the right submatrix of `B₂`
  let x : M₁.Y.Elem → Z2 := M₁.B ⟨a, Set.mem_of_mem_inter_left (by rw [ha]; rfl)⟩ -- the bottom row of `B₁`
  let y : M₂.X.Elem → Z2 := (M₂.B · ⟨a, Set.mem_of_mem_inter_right (by rw [ha]; rfl)⟩) -- the left column of `B₂`
  --
  let B : Matrix ((M₁.X \ {a}) ∪ M₂.X).Elem (M₁.Y ∪ (M₂.Y \ {a})).Elem Z2 :=
    (Matrix.twoSumComposition A₁ x A₂ y).toMatrixUnionUnion rfl rfl
  ⟨
    ⟨
      (M₁.X \ {a}) ∪ M₂.X,
      M₁.Y ∪ (M₂.Y \ {a}),
      (Set.decidableUnion _ _ ·),
      (Set.decidableUnion _ _ ·),
      by
        rw [Set.disjoint_union_right, Set.disjoint_union_left, Set.disjoint_union_left]
        exact ⟨⟨M₁.hXY.disjoint_sdiff_left, hXY⟩, ⟨disjoint_of_singleton_intersection_both_wo ha, M₂.hXY.disjoint_sdiff_right⟩⟩,
      B
    ⟩,
    (M₁.X ⫗ M₂.X ∧ M₁.Y ⫗ M₂.Y) ∧ (x ≠ 0 ∧ y ≠ 0)
  ⟩

/-- Matroid-level 3-sum for matroids defined by their standard representation matrices; now checks legitimacy. -/
noncomputable def BinaryMatroid.threeSum {M₁ M₂ : BinaryMatroid α} {x₁ x₂ x₃ y₁ y₂ y₃ : α}
    (hXX : M₁.X ∩ M₂.X = {x₁, x₂, x₃}) (hYY : M₁.Y ∩ M₂.Y = {y₁, y₂, y₃}) (hXY : M₁.X ⫗ M₂.Y) (hYX : M₁.Y ⫗ M₂.X) :
    BinaryMatroid α × Prop :=
  have hxxx₁ : {x₁, x₂, x₃} ⊆ M₁.X := hXX.symm.subset.trans Set.inter_subset_left
  have hxxx₂ : {x₁, x₂, x₃} ⊆ M₂.X := hXX.symm.subset.trans Set.inter_subset_right
  have hyyy₁ : {y₁, y₂, y₃} ⊆ M₁.Y := hYY.symm.subset.trans Set.inter_subset_left
  have hyyy₂ : {y₁, y₂, y₃} ⊆ M₂.Y := hYY.symm.subset.trans Set.inter_subset_right
  have x₁inX₁ : x₁ ∈ M₁.X := hxxx₁ (Set.mem_insert x₁ {x₂, x₃})
  have x₁inX₂ : x₁ ∈ M₂.X := hxxx₂ (Set.mem_insert x₁ {x₂, x₃})
  have x₂inX₁ : x₂ ∈ M₁.X := hxxx₁ (Set.insert_comm x₁ x₂ {x₃} ▸ Set.mem_insert x₂ {x₁, x₃})
  have x₂inX₂ : x₂ ∈ M₂.X := hxxx₂ (Set.insert_comm x₁ x₂ {x₃} ▸ Set.mem_insert x₂ {x₁, x₃})
  have x₃inX₁ : x₃ ∈ M₁.X := hxxx₁ (by simp)
  have x₃inX₂ : x₃ ∈ M₂.X := hxxx₂ (by simp)
  have y₃inY₁ : y₃ ∈ M₁.Y := hyyy₁ (by simp)
  have y₃inY₂ : y₃ ∈ M₂.Y := hyyy₂ (by simp)
  have y₂inY₁ : y₂ ∈ M₁.Y := hyyy₁ (Set.insert_comm y₁ y₂ {y₃} ▸ Set.mem_insert y₂ {y₁, y₃})
  have y₂inY₂ : y₂ ∈ M₂.Y := hyyy₂ (Set.insert_comm y₁ y₂ {y₃} ▸ Set.mem_insert y₂ {y₁, y₃})
  have y₁inY₁ : y₁ ∈ M₁.Y := hyyy₁ (Set.mem_insert y₁ {y₂, y₃})
  have y₁inY₂ : y₁ ∈ M₂.Y := hyyy₂ (Set.mem_insert y₁ {y₂, y₃})
  -- The actual definition starts here:
  let A₁ : Matrix (M₁.X \ {x₁, x₂, x₃}).Elem ((M₁.Y \ {y₁, y₂, y₃}).Elem ⊕ Fin 2) Z2 := -- the top left submatrix
    (fun i j => M₁.B ⟨i.val, Set.mem_of_mem_diff i.property⟩
        (j.casesOn (fun j' => ⟨j'.val, Set.mem_of_mem_diff j'.property⟩) ![⟨y₂, y₂inY₁⟩, ⟨y₁, y₁inY₁⟩]))
  let A₂ : Matrix (Fin 2 ⊕ (M₂.X \ {x₁, x₂, x₃}).Elem) (M₂.Y \ {y₁, y₂, y₃}).Elem Z2 := -- the bottom right submatrix
    (fun i j => M₂.B (i.casesOn ![⟨x₂, x₂inX₂⟩, ⟨x₃, x₃inX₂⟩] (fun i' => ⟨i'.val, Set.mem_of_mem_diff i'.property⟩))
        ⟨j.val, Set.mem_of_mem_diff j.property⟩)
  let z₁ : (M₁.Y \ {y₁, y₂, y₃}).Elem → Z2 := -- the middle left "row vector"
    (fun j => M₁.B ⟨x₁, x₁inX₁⟩ ⟨j.val, Set.mem_of_mem_diff j.property⟩)
  let z₂ : (M₂.X \ {x₁, x₂, x₃}).Elem → Z2 := -- the bottom middle "column vector"
    (fun i => M₂.B ⟨i.val, Set.mem_of_mem_diff i.property⟩ ⟨y₃, y₃inY₂⟩)
  let D_₁ : Matrix (Fin 2) (Fin 2) Z2 := -- the bottom middle 2x2 submatrix
    (fun i j => M₁.B (![⟨x₂, x₂inX₁⟩, ⟨x₃, x₃inX₁⟩] i) (![⟨y₂, y₂inY₁⟩, ⟨y₁, y₁inY₁⟩] j))
  let D_₂ : Matrix (Fin 2) (Fin 2) Z2 := -- the middle left 2x2 submatrix
    (fun i j => M₂.B (![⟨x₂, x₂inX₂⟩, ⟨x₃, x₃inX₂⟩] i) (![⟨y₂, y₂inY₂⟩, ⟨y₁, y₁inY₂⟩] j))
  let D₁ : Matrix (Fin 2) (M₁.Y \ {y₁, y₂, y₃}).Elem Z2 := -- the bottom left submatrix
    (fun i j => M₁.B (![⟨x₂, x₂inX₁⟩, ⟨x₃, x₃inX₁⟩] i) ⟨j.val, Set.mem_of_mem_diff j.property⟩)
  let D₂ : Matrix (M₂.X \ {x₁, x₂, x₃}).Elem (Fin 2) Z2 := -- the bottom left submatrix
    (fun i j => M₂.B ⟨i.val, Set.mem_of_mem_diff i.property⟩ (![⟨y₂, y₂inY₂⟩, ⟨y₁, y₁inY₂⟩] j))
  ⟨
    ⟨
      (M₁.X \ {x₁, x₂, x₃}) ∪ M₂.X,
      M₁.Y ∪ (M₂.Y \ {y₁, y₂, y₃}),
      (Set.decidableUnion _ _ ·),
      (Set.decidableUnion _ _ ·),
      by
        rw [Set.disjoint_union_right, Set.disjoint_union_left, Set.disjoint_union_left]
        exact
          ⟨⟨M₁.hXY.disjoint_sdiff_left, hYX.symm⟩, ⟨hXY.disjoint_sdiff_right.disjoint_sdiff_left, M₂.hXY.disjoint_sdiff_right⟩⟩,
      Matrix.of (fun i j =>
        Matrix.threeSumComposition A₁ A₂ z₁ z₂ D_₁ D₁ D₂ (
          if hi₁ : i.val ∈ M₁.X \ {x₁, x₂, x₃} then Sum.inl (Sum.inl ⟨i, hi₁⟩) else
          if hi₂ : i.val ∈ M₂.X \ {x₁, x₂, x₃} then Sum.inr (Sum.inr ⟨i, hi₂⟩) else
          if hx₁ : i.val = x₁ then Sum.inl (Sum.inr ()) else
          if hx₂ : i.val = x₂ then Sum.inr (Sum.inl 0) else
          if hx₃ : i.val = x₃ then Sum.inr (Sum.inl 1) else
          (i.property.elim hi₁ (by simp_all)).elim
          -- TODO can `Matrix.toMatrixUnionUnion` be combined with something else to simplify this definition?
        ) (
          if hj₁ : j.val ∈ M₁.Y \ {y₁, y₂, y₃} then Sum.inl (Sum.inl ⟨j, hj₁⟩) else
          if hj₂ : j.val ∈ M₂.Y \ {y₁, y₂, y₃} then Sum.inr (Sum.inr ⟨j, hj₂⟩) else
          if hy₁ : j.val = y₁ then Sum.inl (Sum.inr 1) else
          if hy₂ : j.val = y₂ then Sum.inl (Sum.inr 0) else
          if hy₃ : j.val = y₃ then Sum.inr (Sum.inl ()) else
          (j.property.elim (by simp_all) hj₂).elim
        )
      )
    ⟩,
    IsUnit D_₁ ∧ D_₁ = D_₂ -- the matrix `D_₁ = D_₂` (called D-bar in the book) is invertible
    ∧ M₁.B ⟨x₁, x₁inX₁⟩ ⟨y₁, y₁inY₁⟩ = 1
    ∧ M₁.B ⟨x₁, x₁inX₁⟩ ⟨y₂, y₂inY₁⟩ = 1
    ∧ M₁.B ⟨x₂, x₂inX₁⟩ ⟨y₃, y₃inY₁⟩ = 1
    ∧ M₁.B ⟨x₃, x₃inX₁⟩ ⟨y₃, y₃inY₁⟩ = 1
    ∧ M₂.B ⟨x₁, x₁inX₂⟩ ⟨y₁, y₁inY₂⟩ = 1
    ∧ M₂.B ⟨x₁, x₁inX₂⟩ ⟨y₂, y₂inY₂⟩ = 1
    ∧ M₂.B ⟨x₂, x₂inX₂⟩ ⟨y₃, y₃inY₂⟩ = 1
    ∧ M₂.B ⟨x₃, x₃inX₂⟩ ⟨y₃, y₃inY₂⟩ = 1
    ∧ (∀ x : α, ∀ hx : x ∈ M₁.X, x ≠ x₂ ∧ x ≠ x₃ → M₁.B ⟨x, hx⟩ ⟨y₃, y₃inY₁⟩ = 0) -- the rest of the rightmost column is `0`s
    ∧ (∀ y : α, ∀ hy : y ∈ M₂.Y, y ≠ y₂ ∧ y ≠ y₁ → M₂.B ⟨x₁, x₁inX₂⟩ ⟨y, hy⟩ = 0) -- the rest of the topmost row is `0`s
  ⟩

/-- Matroid `M` is a result of 1-summing `M₁` and `M₂` (should be equivalent to direct sums). -/
def BinaryMatroid.Is1sumOf (M : BinaryMatroid α) (M₁ M₂ : BinaryMatroid α) : Prop :=
  ∃ hXY : M₁.X ⫗ M₂.Y, ∃ hYX : M₁.Y ⫗ M₂.X,
    let M₀ := BinaryMatroid.oneSum hXY hYX
    M = M₀.fst ∧ M₀.snd

/-- Matroid `M` is a result of 2-summing `M₁` and `M₂` in some way. -/
def BinaryMatroid.Is2sumOf (M : BinaryMatroid α) (M₁ M₂ : BinaryMatroid α) : Prop :=
  ∃ a : α, ∃ ha : M₁.X ∩ M₂.Y = {a}, ∃ hXY : M₂.X ⫗ M₁.Y,
    let M₀ := BinaryMatroid.twoSum ha hXY
    M = M₀.fst ∧ M₀.snd

/-- Matroid `M` is a result of 3-summing `M₁` and `M₂` in some way. -/
def BinaryMatroid.Is3sumOf (M : BinaryMatroid α) (M₁ M₂ : BinaryMatroid α) : Prop :=
  ∃ x₁ x₂ x₃ y₁ y₂ y₃ : α,
    ∃ hXX : M₁.X ∩ M₂.X = {x₁, x₂, x₃}, ∃ hYY : M₁.Y ∩ M₂.Y = {y₁, y₂, y₃}, ∃ hXY : M₁.X ⫗ M₂.Y, ∃ hYX : M₁.Y ⫗ M₂.X,
      let M₀ := BinaryMatroid.threeSum hXX hYY hXY hYX
      M = M₀.fst ∧ M₀.snd

section API_for_3sum

variable {M M₁ M₂ : BinaryMatroid α}

lemma BinaryMatroid.Is3sumOf.interXX (hM : M.Is3sumOf M₁ M₂) :
    ∃ x₁ x₂ x₃ : α, M₁.X ∩ M₂.X = {x₁, x₂, x₃} := by
  obtain ⟨x₁, x₂, x₃, -, -, -, hXX, -⟩ := hM
  exact ⟨x₁, x₂, x₃, hXX⟩

lemma BinaryMatroid.Is3sumOf.interYY (hM : M.Is3sumOf M₁ M₂) :
    ∃ y₁ y₂ y₃ : α, M₁.Y ∩ M₂.Y = {y₁, y₂, y₃} := by
  obtain ⟨-, -, -, y₁, y₂, y₃, -, hYY, -⟩ := hM
  exact ⟨y₁, y₂, y₃, hYY⟩

lemma BinaryMatroid.Is3sumOf.disjoXY (hM : M.Is3sumOf M₁ M₂) :
    M₁.X ⫗ M₂.Y := by
  obtain ⟨-, -, -, -, -, -, -, -, hXY, -⟩ := hM
  exact hXY

lemma BinaryMatroid.Is3sumOf.disjoYX (hM : M.Is3sumOf M₁ M₂) :
    M₁.Y ⫗ M₂.X := by
  obtain ⟨-, -, -, -, -, -, -, -, -, hYX, -⟩ := hM
  exact hYX

lemma BinaryMatroid.Is3sumOf.Indep (hM : M.Is3sumOf M₁ M₂) :
    ∃ x₁ x₂ x₃ y₁ y₂ y₃ : α,
      ∃ x₁inX₁ : x₁ ∈ M₁.X,
      ∃ x₂inX₁ : x₂ ∈ M₁.X,
      ∃ x₂inX₂ : x₂ ∈ M₂.X,
      ∃ x₃inX₁ : x₃ ∈ M₁.X,
      ∃ x₃inX₂ : x₃ ∈ M₂.X,
      ∃ y₃inY₂ : y₃ ∈ M₂.Y,
      ∃ y₂inY₁ : y₂ ∈ M₁.Y,
      ∃ y₂inY₂ : y₂ ∈ M₂.Y,
      ∃ y₁inY₁ : y₁ ∈ M₁.Y,
      ∃ y₁inY₂ : y₁ ∈ M₂.Y,
      let A₁ : Matrix (M₁.X \ {x₁, x₂, x₃}).Elem ((M₁.Y \ {y₁, y₂, y₃}).Elem ⊕ Fin 2) Z2 := -- the top left submatrix
        (fun i j => M₁.B ⟨i.val, Set.mem_of_mem_diff i.property⟩
            (j.casesOn (fun j' => ⟨j'.val, Set.mem_of_mem_diff j'.property⟩) ![⟨y₂, y₂inY₁⟩, ⟨y₁, y₁inY₁⟩]))
      let A₂ : Matrix (Fin 2 ⊕ (M₂.X \ {x₁, x₂, x₃}).Elem) (M₂.Y \ {y₁, y₂, y₃}).Elem Z2 := -- the bottom right submatrix
        (fun i j => M₂.B (i.casesOn ![⟨x₂, x₂inX₂⟩, ⟨x₃, x₃inX₂⟩] (fun i' => ⟨i'.val, Set.mem_of_mem_diff i'.property⟩))
            ⟨j.val, Set.mem_of_mem_diff j.property⟩)
      let z₁ : (M₁.Y \ {y₁, y₂, y₃}).Elem → Z2 := -- the middle left "row vector"
        (fun j => M₁.B ⟨x₁, x₁inX₁⟩ ⟨j.val, Set.mem_of_mem_diff j.property⟩)
      let z₂ : (M₂.X \ {x₁, x₂, x₃}).Elem → Z2 := -- the bottom middle "column vector"
        (fun i => M₂.B ⟨i.val, Set.mem_of_mem_diff i.property⟩ ⟨y₃, y₃inY₂⟩)
      let D_₁ : Matrix (Fin 2) (Fin 2) Z2 := -- the bottom middle 2x2 submatrix
        (fun i j => M₁.B (![⟨x₂, x₂inX₁⟩, ⟨x₃, x₃inX₁⟩] i) (![⟨y₂, y₂inY₁⟩, ⟨y₁, y₁inY₁⟩] j))
      let D₁ : Matrix (Fin 2) (M₁.Y \ {y₁, y₂, y₃}).Elem Z2 := -- the bottom left submatrix
        (fun i j => M₁.B (![⟨x₂, x₂inX₁⟩, ⟨x₃, x₃inX₁⟩] i) ⟨j.val, Set.mem_of_mem_diff j.property⟩)
      let D₂ : Matrix (M₂.X \ {x₁, x₂, x₃}).Elem (Fin 2) Z2 := -- the bottom left submatrix
        (fun i j => M₂.B ⟨i.val, Set.mem_of_mem_diff i.property⟩ (![⟨y₂, y₂inY₂⟩, ⟨y₁, y₁inY₂⟩] j))
      (Matrix.of (
        fun i : ((M₁.X \ {x₁, x₂, x₃}) ∪ M₂.X).Elem =>
        fun j : (M₁.Y ∪ (M₂.Y \ {y₁, y₂, y₃})).Elem =>
          Matrix.threeSumComposition A₁ A₂ z₁ z₂ D_₁ D₁ D₂ (
            if hi₁ : i.val ∈ M₁.X \ {x₁, x₂, x₃} then Sum.inl (Sum.inl ⟨i, hi₁⟩) else
            if hi₂ : i.val ∈ M₂.X \ {x₁, x₂, x₃} then Sum.inr (Sum.inr ⟨i, hi₂⟩) else
            if hx₁ : i.val = x₁ then Sum.inl (Sum.inr ()) else
            if hx₂ : i.val = x₂ then Sum.inr (Sum.inl 0) else
            if hx₃ : i.val = x₃ then Sum.inr (Sum.inl 1) else
            (i.property.elim hi₁ (by simp_all)).elim
          ) (
            if hj₁ : j.val ∈ M₁.Y \ {y₁, y₂, y₃} then Sum.inl (Sum.inl ⟨j, hj₁⟩) else
            if hj₂ : j.val ∈ M₂.Y \ {y₁, y₂, y₃} then Sum.inr (Sum.inr ⟨j, hj₂⟩) else
            if hy₁ : j.val = y₁ then Sum.inl (Sum.inr 1) else
            if hy₂ : j.val = y₂ then Sum.inl (Sum.inr 0) else
            if hy₃ : j.val = y₃ then Sum.inr (Sum.inl ()) else
            (j.property.elim (by simp_all) hj₂).elim
          )
        )
      ).IndepCols = M.toMatroid.Indep := by
  obtain ⟨x₁, x₂, x₃, y₁, y₂, y₃, hXX, hYY, -, -, rfl, -⟩ := hM
  have hxxx₁ : {x₁, x₂, x₃} ⊆ M₁.X := hXX.symm.subset.trans Set.inter_subset_left
  have hxxx₂ : {x₁, x₂, x₃} ⊆ M₂.X := hXX.symm.subset.trans Set.inter_subset_right
  have hyyy₁ : {y₁, y₂, y₃} ⊆ M₁.Y := hYY.symm.subset.trans Set.inter_subset_left
  have hyyy₂ : {y₁, y₂, y₃} ⊆ M₂.Y := hYY.symm.subset.trans Set.inter_subset_right
  exact ⟨x₁, x₂, x₃, y₁, y₂, y₃,
    hxxx₁ (Set.mem_insert x₁ {x₂, x₃}),
    hxxx₁ (Set.insert_comm x₁ x₂ {x₃} ▸ Set.mem_insert x₂ {x₁, x₃}),
    hxxx₂ (Set.insert_comm x₁ x₂ {x₃} ▸ Set.mem_insert x₂ {x₁, x₃}),
    hxxx₁ (by simp),
    hxxx₂ (by simp),
    hyyy₂ (by simp),
    hyyy₁ (Set.insert_comm y₁ y₂ {y₃} ▸ Set.mem_insert y₂ {y₁, y₃}),
    hyyy₂ (Set.insert_comm y₁ y₂ {y₃} ▸ Set.mem_insert y₂ {y₁, y₃}),
    hyyy₁ (Set.mem_insert y₁ {y₂, y₃}),
    hyyy₂ (Set.mem_insert y₁ {y₂, y₃}),
    rfl⟩

lemma BinaryMatroid.Is3sumOf.invertibilityDbar (hM : M.Is3sumOf M₁ M₂) :
    ∃ x₂ x₃ y₁ y₂ : α, ∃ x₂inX₁ : x₂ ∈ M₁.X, ∃ x₃inX₁ : x₃ ∈ M₁.X, ∃ y₂inY₁ : y₂ ∈ M₁.Y, ∃ y₁inY₁ : y₁ ∈ M₁.Y,
      IsUnit (Matrix.of (fun i j => M₁.B (![⟨x₂, x₂inX₁⟩, ⟨x₃, x₃inX₁⟩] i) (![⟨y₂, y₂inY₁⟩, ⟨y₁, y₁inY₁⟩] j))) := by
  obtain ⟨x₁, x₂, x₃, y₁, y₂, y₃, hXX, hYY, _, _, rfl, valid⟩ := hM
  use x₂, x₃, y₁, y₂
  have hxxx₁ : {x₁, x₂, x₃} ⊆ M₁.X := hXX.symm.subset.trans Set.inter_subset_left
  use hxxx₁ (Set.insert_comm x₁ x₂ {x₃} ▸ Set.mem_insert x₂ {x₁, x₃}), hxxx₁ (by simp)
  have hyyy₁ : {y₁, y₂, y₃} ⊆ M₁.Y := hYY.symm.subset.trans Set.inter_subset_left
  use hyyy₁ (Set.insert_comm y₁ y₂ {y₃} ▸ Set.mem_insert y₂ {y₁, y₃}), hyyy₁ (Set.mem_insert y₁ {y₂, y₃})
  unfold BinaryMatroid.threeSum at valid
  aesop

end API_for_3sum

def Matrix.TU.toMatrixUnionUnion {T T₁ T₂ S S₁ S₂ : Set α}
    [∀ a, Decidable (a ∈ T₁)] [∀ a, Decidable (a ∈ T₂)] [∀ a, Decidable (a ∈ S₁)] [∀ a, Decidable (a ∈ S₂)]
    {C : Matrix (T₁ ⊕ T₂) (S₁ ⊕ S₂) ℚ} (hC : C.TU) (hT : T = T₁ ∪ T₂) (hS : S = S₁ ∪ S₂) :
    (C.toMatrixUnionUnion hT hS).TU := by
  rw [Matrix.TU_iff] at hC ⊢
  intros
  apply hC

/-- Any 1-sum of regular matroids is a regular matroid. -/
theorem BinaryMatroid.Is1sum.isRegular {M M₁ M₂ : BinaryMatroid α}
    (hM : M.Is1sumOf M₁ M₂) (hM₁ : M₁.IsRegular) (hM₂ : M₂.IsRegular) :
    M.IsRegular := by
  obtain ⟨hXY, hYX, hMsum, -⟩ := hM
  obtain ⟨B₁, hB₁, hBB₁⟩ := hM₁
  obtain ⟨B₂, hB₂, hBB₂⟩ := hM₂
  let B' := Matrix.oneSumComposition B₁ B₂
  have hB' : B'.TU
  · apply Matrix.fromBlocks_TU
    · rwa [Matrix.TU_adjoin_id_left_iff] at hB₁
    · rwa [Matrix.TU_adjoin_id_left_iff] at hB₂
  have hMX : M.X = M₁.X ∪ M₂.X := by simp only [BinaryMatroid.oneSum, hMsum]
  have hMY : M.Y = M₁.Y ∪ M₂.Y := by simp only [BinaryMatroid.oneSum, hMsum]
  use B'.toMatrixUnionUnion hMX hMY
  constructor
  · rw [Matrix.TU_adjoin_id_left_iff]
    exact hB'.toMatrixUnionUnion hMX hMY
  · intro i j
    have hMB : M.B = (Matrix.oneSumComposition M₁.B M₂.B).toMatrixUnionUnion hMX hMY
    · subst hMsum
      unfold BinaryMatroid.oneSum
      ext
      simp only [Matrix.oneSumComposition, Matrix.toMatrixUnionUnion, convertUnionSum]
    rw [hMB]
    simp only [Matrix.oneSumComposition, Matrix.toMatrixUnionUnion] at *
    split <;>
    · cases hi : convertUnionSum (hMX ▸ i) with
      | inl i₁ =>
        cases hj : convertUnionSum (hMY ▸ j) with
        | inl j₁ =>
          specialize hBB₁ i₁ j₁
          aesop
        | inr j₂ =>
          aesop
      | inr i₂ =>
        cases hj : convertUnionSum (hMY ▸ j) with
        | inl j₁ =>
          aesop
        | inr j₂ =>
          specialize hBB₂ i₂ j₂
          aesop

lemma Matrix.twoSumComposition_TU {X₁ Y₁ : Set α} {X₂ Y₂ : Set α} {A₁ : Matrix X₁ Y₁ ℚ} {A₂ : Matrix X₂ Y₂ ℚ}
    (hA₁ : A₁.TU) (hA₂ : A₂.TU) (x : Y₁ → ℚ) (y : X₂ → ℚ) :
    (Matrix.twoSumComposition A₁ x A₂ y).TU := by
  sorry

/-- Any 2-sum of regular matroids is a regular matroid. -/
theorem BinaryMatroid.Is2sum.isRegular {M M₁ M₂ : BinaryMatroid α}
    (hM : M.Is2sumOf M₁ M₂) (hM₁ : M₁.IsRegular) (hM₂ : M₂.IsRegular) :
    M.IsRegular := by
  obtain ⟨a, ha, haX₂, hM, ⟨hXX, hYY⟩, ⟨hx, hy⟩⟩ := hM
  obtain ⟨B₁, hB₁, hBB₁⟩ := hM₁
  obtain ⟨B₂, hB₂, hBB₂⟩ := hM₂
  have haXY : a ∈ M₁.X ∩ M₂.Y
  · rewrite [ha]
    rfl
  have haX₁ : a ∈ M₁.X := Set.mem_of_mem_inter_left haXY
  have haY₂ : a ∈ M₂.Y := Set.mem_of_mem_inter_right haXY
  let x' : M₁.Y.Elem → ℚ := B₁ ⟨a, haX₁⟩
  let y' : M₂.X.Elem → ℚ := (B₂ · ⟨a, haY₂⟩)
  let B' := Matrix.twoSumComposition B₁ x' B₂ y'
  have hB' : B'.TU
  · apply Matrix.twoSumComposition_TU
    · rwa [Matrix.TU_adjoin_id_left_iff] at hB₁
    · rwa [Matrix.TU_adjoin_id_left_iff] at hB₂
  have hMX : M.X = (M₁.X \ {a}) ∪ M₂.X
  · simp only [BinaryMatroid.twoSum, hM]
  have hMY : M.Y = M₁.Y ∪ (M₂.Y \ {a})
  · simp only [BinaryMatroid.twoSum, hM]
  sorry

/-- Any 3-sum of regular matroids is a regular matroid. -/
theorem BinaryMatroid.Is3sum.isRegular {M M₁ M₂ : BinaryMatroid α}
    (hM : M.Is3sumOf M₁ M₂) (hM₁ : M₁.IsRegular) (hM₂ : M₂.IsRegular) :
    M.IsRegular := by
  obtain ⟨eX, eY, hMXY⟩ := hM
  obtain ⟨B₁', hB₁, hBB₁⟩ := hM₁
  obtain ⟨B₂', hB₂, hBB₂⟩ := hM₂
  sorry
