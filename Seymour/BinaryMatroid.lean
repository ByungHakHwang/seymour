import Mathlib.Data.Matroid.IndepAxioms

import Seymour.Preamble


/-- Data describing a binary matroid on the ground set `X ∪ Y` where `X` and `Y` are bundled. -/
structure BinaryMatroid (α : Type*) [DecidableEq α] where
  X : Set α
  Y : Set α
  decmemX : ∀ a, Decidable (a ∈ X)
  decmemY : ∀ a, Decidable (a ∈ Y)
  hXY : X ⫗ Y
  B : Matrix X Y Z2

attribute [instance] BinaryMatroid.decmemX
attribute [instance] BinaryMatroid.decmemY


variable {α : Type*} {X Y : Set α}
variable [∀ a, Decidable (a ∈ X)] [∀ a, Decidable (a ∈ Y)] [DecidableEq α]
-- Note that `variable [DecidablePred X.Mem] [DecidablePred Y.Mem]` does not work.

/-- Given matrix `B`, is the set of columns `S` in the (standard) representation [`1` | `B`] `Z2`-independent? -/
def Matrix.IndepCols (B : Matrix X Y Z2) (S : Set α) : Prop :=
  ∃ hs : S ⊆ X ∪ Y,
    LinearIndependent Z2 ((Matrix.fromColumns 1 B).submatrix id (Subtype.toSum ∘ hs.elem)).transpose


/-- The empty set of columns in linearly independent. -/
theorem Matrix.IndepCols_empty {B : Matrix X Y Z2} : B.IndepCols ∅ := by
  use Set.empty_subset (X ∪ Y)
  exact linearIndependent_empty_type

/-- A subset of a linearly independent set of columns in linearly independent. -/
theorem Matrix.IndepCols_subset {B : Matrix X Y Z2} (I J : Set α) (hBJ : B.IndepCols J) (hIJ : I ⊆ J) :
    B.IndepCols I := by
  obtain ⟨hJ, hB⟩ := hBJ
  use hIJ.trans hJ
  let I' := { i : J.Elem // i.val ∈ I }
  let e : I' ≃ I := (Equiv.subtypeSubtypeEquivSubtype (by convert hIJ))
  sorry

/-- A nonmaximal linearly independent set of columns can be augmented with another linearly independent column. -/
theorem Matrix.IndepCols_augment {B : Matrix X Y Z2} (I J : Set α)
    (hBI : B.IndepCols I) (hBI' : ¬Maximal B.IndepCols I) (hBJ : Maximal B.IndepCols J) :
    ∃ x ∈ J \ I, B.IndepCols (x ᕃ I) := by
  sorry

/-- Any set of columns has the maximal subset property. -/
theorem Matrix.IndepCols_maximal {B : Matrix X Y Z2} (S : Set α) :
    Matroid.ExistsMaximalSubsetProperty B.IndepCols S := by
  sorry


/-- Binary matroid generated by its standard representation matrix, expressed as `IndepMatroid`. -/
def Matrix.toIndepMatroid (B : Matrix X Y Z2) : IndepMatroid α where
  E := X ∪ Y
  Indep := B.IndepCols
  indep_empty := B.IndepCols_empty
  indep_subset := B.IndepCols_subset
  indep_aug := B.IndepCols_augment
  indep_maximal S _ := B.IndepCols_maximal S
  subset_ground _ := Exists.fst

/-- Binary matroid generated by its standard representation matrix, expressed as `Matroid`. -/
def Matrix.toMatroid (B : Matrix X Y Z2) : Matroid α := B.toIndepMatroid.matroid

def BinaryMatroid.toMatroid (M : BinaryMatroid α) := M.B.toMatroid

@[simp]
lemma BinaryMatroid.E_eq (M : BinaryMatroid α) : M.toMatroid.E = M.X ∪ M.Y := rfl

@[simp]
lemma BinaryMatroid.indep_eq (M : BinaryMatroid α) : M.toMatroid.Indep = M.B.IndepCols := rfl

instance : Coe (BinaryMatroid α) (Matroid α) where coe := BinaryMatroid.toMatroid

/-- The binary matroid is regular. -/
def BinaryMatroid.IsRegular (M : BinaryMatroid α) : Prop :=
  ∃ B' : Matrix M.X M.Y ℤ, -- signed version of `B`
    (Matrix.fromColumns (1 : Matrix M.X M.X ℤ) B').TU ∧ -- the signed representation matrix is totally unimodular
    ∀ i : M.X, ∀ j : M.Y, if M.B i j = 0 then B' i j = 0 else B' i j = 1 ∨ B' i j = -1 -- in absolulute values `B' = B`
